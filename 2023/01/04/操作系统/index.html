<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统 | Coko</title><meta name="author" content="SuperCoko"><meta name="copyright" content="SuperCoko"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统 来自王道计算机操作系统 1章 1天 2章 4天 3章 2天 4章 2天 5章 1天 共10天  第一章1.1 操作系统概念, 功能和目标概念操作系统  负责管理协调硬件,软件等计算机资源的工作 为商城的应用程序, 用户提供简单医用的服务 最基本的系统软件  功能和目标ps. 程序执行前要将其放置内存, 才能被cpu处理   作为系统资源的管理者   提供的功能 处理机管理 存储器管理 文">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://supercoko.github.io/2023/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Coko">
<meta property="og:description" content="操作系统 来自王道计算机操作系统 1章 1天 2章 4天 3章 2天 4章 2天 5章 1天 共10天  第一章1.1 操作系统概念, 功能和目标概念操作系统  负责管理协调硬件,软件等计算机资源的工作 为商城的应用程序, 用户提供简单医用的服务 最基本的系统软件  功能和目标ps. 程序执行前要将其放置内存, 才能被cpu处理   作为系统资源的管理者   提供的功能 处理机管理 存储器管理 文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images4.alphacoders.com/129/1297318.jpg">
<meta property="article:published_time" content="2023-01-04T10:16:46.000Z">
<meta property="article:modified_time" content="2023-02-10T03:59:23.956Z">
<meta property="article:author" content="SuperCoko">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images4.alphacoders.com/129/1297318.jpg"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="https://supercoko.github.io/2023/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: SuperCoko","link":"链接: ","source":"来源: Coko","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-10 11:59:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic4.zhimg.com/v2-c21606cc260d1e83272a3b3243a2ff17_r.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images4.alphacoders.com/129/1297318.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Coko</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统<a class="post-edit-link" href="null_posts/操作系统.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-04T10:16:46.000Z" title="发表于 2023-01-04 18:16:46">2023-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-10T03:59:23.956Z" title="更新于 2023-02-10 11:59:23">2023-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><hr>
<p>来自王道计算机操作系统</p>
<p>1章 1天</p>
<p>2章 4天</p>
<p>3章 2天</p>
<p>4章 2天</p>
<p>5章 1天</p>
<p>共10天</p>
<hr>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1-操作系统概念-功能和目标"><a href="#1-1-操作系统概念-功能和目标" class="headerlink" title="1.1 操作系统概念, 功能和目标"></a>1.1 操作系统概念, 功能和目标</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>操作系统</p>
<ul>
<li>负责管理协调硬件,软件等计算机资源的工作</li>
<li>为商城的应用程序, 用户提供简单医用的服务</li>
<li>最基本的系统软件</li>
</ul>
<h4 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h4><p>ps. 程序执行前要将其放置内存, 才能被cpu处理</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104182757205.png" alt="image-20230104182757205"></p>
<ol>
<li>作为系统资源的管理者</li>
</ol>
<ul>
<li>提供的功能<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标<ul>
<li>安全高效</li>
</ul>
</li>
</ul>
<ol start="2">
<li>作为用户和计算及硬件之间的接口</li>
</ol>
<ul>
<li>提供的功能<ul>
<li>命令接口 用户直接使用 (和程序接口统称为用户接口)<ul>
<li>联机命令接口 (交互式命令接口)</li>
<li>脱机命令接口 (批处理命令接口)</li>
</ul>
</li>
<li>程序接口 用户通过程序间接使用 </li>
<li>GUI(图形用户界面)</li>
</ul>
</li>
<li>目标<ul>
<li>方用户使用</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104183339607.png" alt="image-20230104183339607"></p>
<p>系统调用&#x3D;广义指令</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104183641446.png" alt="image-20230104183641446"></p>
<ol start="3">
<li>作为最接近硬件的层次</li>
</ol>
<ul>
<li>扩充机器</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104183917372.png" alt="image-20230104183917372"></p>
<h3 id="1-2-操作系统的四个特征"><a href="#1-2-操作系统的四个特征" class="headerlink" title="1.2 操作系统的四个特征"></a>1.2 操作系统的四个特征</h3><p>特征</p>
<ul>
<li><p>并发</p>
<ul>
<li>指两个或多个事件同一时间间隔内发生, 宏观是同时, 但微观是交替发生</li>
<li>并行 - 两或多个事件同一时刻同时发生</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li><p>即资源共享, 系统汇总的资源科提供内存中多个并发执行的进程共同使用 </p>
</li>
<li><p>两种方式</p>
<ul>
<li><p>互斥共享</p>
<ul>
<li>一个时间段只允许一个进程访问该资源</li>
</ul>
</li>
<li><p>同时共享</p>
<ul>
<li>一个时间段允许n个进程访问</li>
<li>同时是宏观的, 微观上可能是交替共享-分时共享</li>
</ul>
</li>
<li><blockquote>
<p>并发共享互为存在条件</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟 </p>
<ul>
<li>把一个物理实体变为若干个逻辑上的对应物, 前者实际存在, 后者用户感知</li>
<li>虚拟技术<ul>
<li>空分复用技术(如虚拟存储器技术)</li>
<li>时分复用技术(如虚拟处理器) <ul>
<li>没有并发性, 就谈不上虚拟性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>允许多个程序并发执行,但资源有限, 进程的执行不是一贯到底的, 而是走走停停, 已不可预知的速度向前推进, 这就是进程的异步性</li>
<li>只有拥有并发性, 才有可能导致异步性</li>
</ul>
</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104233102749.png" alt="image-20230104233102749"></p>
<p>并发共享互为存在条件</p>
<h3 id="1-3-操作系统的发展和分类"><a href="#1-3-操作系统的发展和分类" class="headerlink" title="1.3 操作系统的发展和分类"></a>1.3 操作系统的发展和分类</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104233201002.png" alt="image-20230104233201002"></p>
<ol>
<li>手工操作阶段</li>
</ol>
<ul>
<li>缺点 <ul>
<li>用户独占全机, 人机速度矛盾导致资源利用率极低</li>
</ul>
</li>
</ul>
<ol start="2">
<li>批处理阶段</li>
</ol>
<ul>
<li>单道批处理技术<ul>
<li>引入脱机输入&#x2F;输出(磁带), 并监督程序负责控制作业的输入,输出</li>
<li>优点<ul>
<li>环节了一定程度的人机速度矛盾, 资源利用率有所提升</li>
</ul>
</li>
<li>缺点<ul>
<li>内存中只能有1道程序运行, cpu有大量时间是在空闲等待I&#x2F;O翻车呢个, 资源利用率还是很低</li>
</ul>
</li>
</ul>
</li>
<li>多道批处理技术<ul>
<li>每次往内存中输入多道程序</li>
<li>操作系统出现</li>
<li>优点<ul>
<li>多道程序并发执行, 共享计算机资源, 资源利用大幅提升,CPU和其他资源保持忙碌状态, 系统吞吐量增大</li>
</ul>
</li>
<li>缺点<ul>
<li>用户响应时间长, 没人机交互功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>分时操作系统</li>
</ol>
<ul>
<li>计算机一时间片为单位轮流为各个用户&#x2F;作业服务, 各个用户可通过终端与计算机进行交互</li>
<li>优点<ul>
<li>用户请求可以被及时响应, 解决了人机交互, 允许多用户同时用一天计算机, 并且用户对计算机的操作相互独立, 感受不到别人的存在</li>
</ul>
</li>
<li>缺点<ul>
<li>不能优先处理紧急任务</li>
</ul>
</li>
</ul>
<ol start="4">
<li>实时操作系统</li>
</ol>
<ul>
<li><p>在实时系统控制下, 计算机系统接收到外部信号后即使进行处理, 并在严格的时限内处理完时间.</p>
</li>
<li><p>及时性和可靠性</p>
<ul>
<li>硬实时</li>
<li>软实时</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>能优先响应紧急任务, 某些紧急任务不需要时间片排队</li>
</ul>
</li>
</ul>
<ol start="4">
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>个人计算机操作系统</li>
</ol>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104235305923.png" alt="image-20230104235305923"></p>
<h3 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230104235434337.png" alt="image-20230104235434337"></p>
<ul>
<li><p>什么是指令</p>
<ul>
<li>处理器能识别,执行的最基本命令</li>
</ul>
</li>
<li><p>运行机制</p>
<ul>
<li>两种指令<ul>
<li>特权指令<ul>
<li>不允许用户使用</li>
</ul>
</li>
<li>非特权指令</li>
</ul>
</li>
<li>两种处理器状态 程序转台寄存器psw中的某标志位,如0 用户态 1 核心态<ul>
<li>用户态 目态<ul>
<li>只能执行非特权指令</li>
</ul>
</li>
<li>核心态 观态<ul>
<li>都可执行</li>
</ul>
</li>
</ul>
</li>
<li>两种程序<ul>
<li>内核程序<ul>
<li>系统的管理者, 运行在核心态</li>
</ul>
</li>
<li>应用程序<ul>
<li>为保证系统安全运行,普通应用程序只能执行非特权指令, 运行在用户态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105000358578.png" alt="image-20230105000358578"></p>
</li>
<li><p>操作系统的内核</p>
<ul>
<li>内核是计算机配置上的底层软件, 是操作系统最基本, 最核心的部分</li>
<li>实现操作系统内核功能的那些程序就是内核程序</li>
<li>组成<ul>
<li>时钟管理 实现计时功能</li>
<li>终端处理 实现中断机制</li>
<li>原语<ul>
<li>特殊的程序</li>
<li>处于操作系统底层, 最接近硬件</li>
<li>具有原子性-其运行只能一气呵成, 不能中断</li>
<li>运行时间短, 调用频繁</li>
</ul>
</li>
<li>对系统资源进行管理 (有些操作系统不包含)<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设别管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统的体系结构</p>
<ul>
<li>大内核<ul>
<li>将操作系统的主要功能模块都作为系统内核, 运行在核心态<ul>
<li>优点 高性能</li>
<li>缺点 内核代码庞大,结构混乱, 难以维护</li>
</ul>
</li>
</ul>
</li>
<li>微内核<ul>
<li>只把最基本的功能保留在内核</li>
<li>优点 内核功能少, 结构清晰, 方便维护</li>
<li>缺点 需要拼房地在核心态和用户态之间切换, 性能低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105004252203.png" alt="image-20230105004252203"></p>
<h3 id="1-5-中断和异常"><a href="#1-5-中断和异常" class="headerlink" title="1.5 中断和异常"></a>1.5 中断和异常</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105004452992.png" alt="image-20230105004452992"></p>
<ul>
<li>中断机制诞生 (实现多道程序并发执行)<ul>
<li>发生中断就以为这需要操作系统接入, 开展管理工作</li>
<li>切换位核心态对中断进行处理</li>
</ul>
</li>
<li>中断的概念和作用<ul>
<li>中断发生时, CPU立即进入核心态</li>
<li>中断发生后, 当亲进程展厅, 并由操作系统内核对中断仅行处理</li>
<li>对不同中断信号, 有不同的处理</li>
<li>中断可以使CPU从用户态切换位核心态,使操作系统获得计算机的控制权, 有了中断才能实现多道程序并发执行. </li>
<li>中断是实现 用户态-&gt;核心态 的唯一途径</li>
<li>核心态-&gt;用户态, 通过执行一个特权指令, 将程序状态字PSW标志位设置为用户态</li>
</ul>
</li>
<li>中断的分类 (信号来源)<ul>
<li>内中断 异常&#x2F;例外&#x2F;陷入 (CPU内部)<ul>
<li>资源中断–指令中断</li>
<li>强迫中断<ul>
<li>硬件故障</li>
<li>软件中断</li>
</ul>
</li>
<li>陷入 trap</li>
<li>鼓掌 fault</li>
<li>终止 abort</li>
</ul>
</li>
<li>外中断 中断(狭义上) (CPU外部)<ul>
<li>外设请求 (I&#x2F;O中断请求)</li>
<li>人工干预</li>
</ul>
</li>
</ul>
</li>
<li>外中断的处理过程<ul>
<li>执行完每条指令,CPU都检测是否有外部中断信号</li>
<li>检测到, 则需要保护中断进程的CPU环境(如PSW,程序计数器, 个钟通用寄存器)</li>
<li>根据终端信号类型,转入相应中断处理程序</li>
<li>回复元进程的CPU环境并退出中断, 返回进程继续往下执行</li>
</ul>
</li>
</ul>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105014431969.png" alt="image-20230105014431969"></p>
<h3 id="1-6-系统调用"><a href="#1-6-系统调用" class="headerlink" title="1.6 系统调用"></a>1.6 系统调用</h3><ul>
<li>什么是系统调用, 有何作用<ul>
<li>操作系统作为用户和计算机硬件之间的接口, 需要向上提供一些简单医用的服务, 包括命令接口和程序接口. 程序接口由一组系统调用组成</li>
<li>用户接口<ul>
<li>命令接口 允许用户直接使用<ul>
<li>联机命令接口</li>
<li>脱机命令接口</li>
</ul>
</li>
<li>程序接口 允许用户通过程序间接使用<ul>
<li>由一组系统调用组成</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105014739851.png" alt="image-20230105014739851"></li>
</ul>
</li>
<li>系统调用是系统提供给应用程序使用的接口(可供应用程序调用的特殊函数, 应用程序可以发出系统调用请求来获得操作系统的服务)</li>
<li>应用程序通过系统调用请求操作系统的服务. 系统汇总的各种共享资源由操作系统统一掌管, 因此, 在用户程序中, 凡是与资源有关操作, 都必须通过系统调用, 有系统代为完成, 这样可以保证系统的问定性和安全性,防止用户非法操作</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105020659159.png" alt="image-20230105020659159"><ul>
<li>在核心态下执行</li>
</ul>
</li>
</ul>
</li>
<li>系统调用与库函数的区别</li>
<li>系统调用背后的过程<ul>
<li>传统系统调用参数 -&gt; 执行陷入指令 用户态-&gt;执行系统调用相应服务程序 核心态 -&gt; 返回用户程序</li>
<li>陷入指令时在用户态执行, 执行陷入指令后立即引发一个内中断, 进入核心态</li>
<li>发出系统调用请求时在用户态, 而对系统调用的相应处理在核心态</li>
<li>陷入指令时唯一一个只能在用户态而不能在核心态执行的指令</li>
</ul>
</li>
</ul>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105021431404.png" alt="image-20230105021431404"></p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-1-进程的定义组成和组织方式特征"><a href="#2-1-1-进程的定义组成和组织方式特征" class="headerlink" title="2.1.1 进程的定义组成和组织方式特征"></a>2.1.1 进程的定义组成和组织方式特征</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105204219434.png" alt="image-20230105204219434"></p>
<ul>
<li>进程的定义<ul>
<li>程序<ul>
<li>一个指令序列</li>
</ul>
</li>
<li>引入多道程序技术后<ul>
<li>为方便系统管理, 引入进程和进程实体的概念</li>
<li>系统为每个运行的程序配置一个数据结构, 称为进程控制块 PCB 用来描述进程的各种信息(如代码位置)</li>
</ul>
</li>
<li>PCB 程序段 数据段三部分构成了进程实体(进程映像)</li>
<li>一般情况, 进程实体简称进程<ul>
<li>PCB是进程存在的唯一标准</li>
</ul>
</li>
<li>进程(不同角度)(强调动态性)<ul>
<li>程序的一次执行过程</li>
<li>一个程序机器数据在处理机上顺序执行是发生的活动</li>
<li>具有独立功能的程序在数据集合上运行的过程 是系统进行资源分配和调度的一个独立单位</li>
<li>进程是进程实体的运行过程, 是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
<li>严格说 进程实体是静态的</li>
</ul>
</li>
<li>进程的组成<ul>
<li>程序段<ul>
<li>程序代码存放</li>
</ul>
</li>
<li>数据段<ul>
<li>使用产生的运算数据 (变量…)</li>
</ul>
</li>
<li>PCB (系统通过pcb来管理进程)<ul>
<li>进程描述信息<ul>
<li>进程标识符 PID</li>
<li>用户标识符 UID</li>
</ul>
</li>
<li>进程控制和管理信息<ul>
<li>进程当前状态</li>
<li>进程优先级</li>
</ul>
</li>
<li>资源分配清单<ul>
<li>程序段指针</li>
<li>数据段指针</li>
<li>键盘</li>
<li>鼠标</li>
</ul>
</li>
<li>处理机相关信息<ul>
<li>各种寄存器值<ul>
<li>进程切换是把当前运行情况记录下来, 保存在PCB中, 如程序计数器的值表示当前执行到哪一句</li>
</ul>
</li>
</ul>
</li>
<li>另外一种分类方式<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230106230823932.png" alt="image-20230106230823932"></li>
</ul>
</li>
<li>小结<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230106230945017.png" alt="image-20230106230945017"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程的组织<ul>
<li>进程组成 -&gt; 进程内部有哪些部分构成</li>
<li>进程组织 -&gt; 多个进程间组织问题</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230106231114433.png" alt="image-20230106231114433"></li>
<li>链接方式<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107022100598.png" alt="image-20230107022100598"></li>
</ul>
</li>
<li>索引方式<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107022126997.png" alt="image-20230107022126997"></li>
</ul>
</li>
</ul>
</li>
<li>进程的特征<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107022146754.png" alt="image-20230107022146754"></li>
<li>进程是资源分配,接受调度的基本单位</li>
<li>动态性是进程最基本特征</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
<li>结构性</li>
</ul>
</li>
</ul>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107022327803.png" alt="image-20230107022327803"></p>
<h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107022419433.png" alt="image-20230107022419433"></p>
<ul>
<li>三种基本状态<ul>
<li>运行态 Running 占有CPU 并在CPU上运行 (单核最多一个进程, 双核最多2个)</li>
<li>就绪态 Ready 已具备运行条件, 但没有空闲CPU, 而暂时不能运行 (拥有所有除了CPU之外的资源)</li>
<li>阻塞态 Waiting&#x2F;Blocked&#x2F;等待态 等待某一时间而暂时不嫩运行</li>
</ul>
</li>
<li>另外两种状态<ul>
<li>创建状态 New 又称 新建态 进程正在被创建, 操作系统为进程分配资源初始化PCB</li>
<li>终止状态 Terminated 结束态 进程正在系统中撤销, 操作系统会回收集成拥有的资源, 撤销PCB</li>
</ul>
</li>
<li>进程状态的转换<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107023156528.png" alt="image-20230107023156528"></li>
</ul>
</li>
</ul>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107023259931.png" alt="image-20230107023259931"></p>
<h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1.3 进程控制"></a>2.1.3 进程控制</h3><ul>
<li>进程控制<ul>
<li>主要功能就是对心痛中的所有进程实施有效的管理, 具有创建新进程,撤销已有进程,实现状态转换等功能</li>
<li>进程控制就是要实现状态转换</li>
</ul>
</li>
<li>实现进程控制<ul>
<li>用原语实现进程控制</li>
<li>原语特点是执行期间不允许中断(原子操作)</li>
<li>原语采用关中断指令和开中断指令实现(核心态)</li>
</ul>
</li>
<li>进程控制相关的原语(进程控制会导致进程状态的转换)<ul>
<li>更新PCB<ul>
<li>修改进程状态标志 (所有进程控制原语都会修改)</li>
<li>不多当前进程的CPU使用权 保存其运行环境</li>
<li>某进程开始运行前必然要回复其运行环境</li>
</ul>
</li>
<li>将PCB插入合适队列</li>
<li>分配&#x2F;回收资源</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107031313837.png" alt="image-20230107031313837"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107031404729.png" alt="image-20230107031404729"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107031446739.png" alt="image-20230107031446739"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107031519348.png" alt="image-20230107031519348"></li>
</ul>
</li>
</ul>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107031540360.png" alt="image-20230107031540360"></p>
<h3 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1.4 进程通信"></a>2.1.4 进程通信</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107031604305.png" alt="image-20230107031604305"></p>
<ul>
<li>进程通信<ul>
<li>进程间的信息交换</li>
<li>进程拥有的内存地址控价能相互独立</li>
<li>一个进程不能直接访问另一个进程的地址空间</li>
</ul>
</li>
<li>共享存储<ul>
<li>两个进程对共享空间的访问是互斥的</li>
<li>操作系统只负责提供共享空间和同步互斥工具(如P,V操作)</li>
<li>基于数据结构的共享<ul>
<li>速度慢, 限制多, 低级通讯方式</li>
</ul>
</li>
<li>基于存储区的共享<ul>
<li>在内存中划一块共享存储区, 数据形式存放位置由进程控制, 而不是操作系统, 速度更快, 一种高级通信方式.</li>
</ul>
</li>
</ul>
</li>
<li>管道通信<ul>
<li>管道<ul>
<li>用于连接读写进程的一个共享文件, Pipe文件. 其实就是内存中开辟一个大小固定的缓冲区</li>
</ul>
</li>
<li>只能采用半双工通信, 某一时间内只能单向传输, 双向通信需要两个管道</li>
<li>各进程要互斥地访问管道 (进程1写数据时, 进程2不能读, 进程2读数据是, 进程1不能写入)</li>
<li>数据以字符流形式写入, 当管道写满时, 写进程的write()系统调用会被阻塞, 等待度进程将数据取走, 当读进程将数据全部取走后, 管道变空, 此时读进程的read()系统调用将被阻塞</li>
<li>如果没写满就怒允许读, 没读空就不允许写</li>
<li>数据一旦被读出, 就从管道中被抛弃, 意味着度进程最多只能有1个, 否则可能读错数据</li>
</ul>
</li>
<li>消息传递<ul>
<li>进程间数据交换以 格式化的消息(message) 为单位, 进程通过系统提供的 “发送消息&#x2F;接收消息” 两个原语来进行数据交换</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107033235710.png" alt="image-20230107033235710"></li>
<li>直接通信方式<ul>
<li>直接挂到接受进程的消息缓冲队列</li>
</ul>
</li>
<li>简介通信方式<ul>
<li>先发送到中间实体, 因此也被称为信箱通信方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107033359906.png" alt="image-20230107033359906"></p>
<h3 id="2-1-5-线程概念和多线程模型"><a href="#2-1-5-线程概念和多线程模型" class="headerlink" title="2.1.5 线程概念和多线程模型"></a>2.1.5 线程概念和多线程模型</h3><ul>
<li>线程<ul>
<li>传统的进程是程序执行六的最小单位</li>
<li>进程包含多个线程</li>
<li>引入线程后. 线程为程序执行流的最小单位</li>
<li>轻量级进程</li>
<li>一个基本的CPU执行单元, 也是程序执行流的最小单位</li>
<li>引入线程后, 不仅进程可以并发, 各线程之间也可以并发, 进一步提升了系统的并发度</li>
<li>进程只作为除CPU之外的系统资源的分配单元</li>
</ul>
</li>
<li>变化<ul>
<li>资源分配,调度<ul>
<li>传统进程机制中, 进程是资源分配调度的基本你单位</li>
<li>引入线程, 进程是资源分配的基本单位, 线程是调度的基本单位</li>
</ul>
</li>
<li>并发性<ul>
<li>只能进程间并发</li>
<li>线程也能并发, 提高并发度</li>
</ul>
</li>
<li>系统开销<ul>
<li>传统进程间并发, 需要切换进程的运行环境, 系统开销大</li>
<li>线程间并发, 如果是同一进程内的线程切换, 不需要切换进程环境, 系统开销小</li>
<li>引入线程后, 并发带来系统开销减小</li>
</ul>
</li>
</ul>
</li>
<li>线程的属性<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU, 各个线程可占用不同CPU</li>
<li>每个线程有一个线程ID, 线程控制块TCB</li>
<li>线程也有就绪阻塞运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程不同线程间共享进程资源</li>
<li>有序内存地址空间, 同一进程中的线程间通信无需系统干预</li>
<li>同一进程中的线程切换, 不会引起进程切换</li>
<li>不同今晨中的线程切换, 会引起进程切换</li>
<li>切换同进程内的线程, 系统开销很小</li>
<li>切换进程系统开销较大</li>
</ul>
</li>
<li>线程的实现方式<ul>
<li>用户级线程 User-Level Thread ULT<ul>
<li>由应用程序通过线程库实现</li>
<li>线程管理工作由应用程序负责</li>
<li>用户级线程中, 线程切换可以在用户态下即可完成,无需系统干预</li>
<li>用户级线程对用户不透明, 对系统透明(用户看来有多个线程, 系统内核看来, 意识不到线程)<ul>
<li>对什么透明就是说透过去了, 所以看不到?</li>
</ul>
</li>
<li>用户级线程就是从用户视角能看到的线程</li>
</ul>
</li>
<li>内核级线程 Kernel-Level Thread 内核支持的线程<ul>
<li>内核几线程的管理工作由操作系统内核完成</li>
<li>线程调度, 切换等工作都由内核负责 </li>
<li>因此内核级线程的切换要在核心态</li>
<li>内核几线程就是从操作系统内核视角能看到的线程</li>
<li>同时支持的系统中, n个用户级线程映射到m个内核级线程(n &gt;&#x3D; m)</li>
<li>内核级线程才是处理机分配的单位</li>
</ul>
</li>
</ul>
</li>
<li>多线程模型<ul>
<li>多对一模型 <ul>
<li>多个用户级线程映射到一个内核级线程</li>
<li>优点<ul>
<li>用户级线程切换在用户空间即可王城,不需要切换到核心态, 线程管理系统开销小,效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>一个用户级线程被阻塞后,整个进程都会被阻塞, 并发度不高, 多个线程不可子啊多喝处理机上并行运行</li>
</ul>
</li>
</ul>
</li>
<li>一对一模型<ul>
<li>一个用户级线程映射到一个内核级线程</li>
<li>优点<ul>
<li>一个线程被阻塞, 别的线程还可以执行,并发能力强. 多线程可在多喝处理机上并行执行</li>
</ul>
</li>
<li>缺点<ul>
<li>一个用户进程会占用多个内核级线程, 先传给你谢欢由操作系统内核完成, 需要切换到核心态, 因此线程管理成本高, 开销大</li>
</ul>
</li>
</ul>
</li>
<li>多对多模型<ul>
<li>n用户映射m内核 n&gt;&#x3D;m</li>
<li>克服多对一并发度不高, 又克服一对一开销太大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107053402616.png"></p>
<h3 id="2-2-1-处理机调度的概念-层次"><a href="#2-2-1-处理机调度的概念-层次" class="headerlink" title="2.2.1 处理机调度的概念,层次"></a>2.2.1 处理机调度的概念,层次</h3><ul>
<li>调度的基本概念<ul>
<li>当有一堆任务, 资源有限, 没法同时处理. 需要某种规则来决定这些任务的顺序</li>
<li>处理机调度, 就是从就绪队列中按照一定的算法选择一个进程, 并将处理机分配给它运行,以实现进程的并发执行.</li>
</ul>
</li>
<li>调度的三个层次<ul>
<li>高级调度(作业调度)<ul>
<li>按一定规则从外存上处于后备队列的作业中挑一个或多个作业, 给他们分配内存等必要资源, 并建立相应的进程(建立PCB), 以使它们获得竞争处理机的权利</li>
<li>高级调度是辅存(外存)与内存之间的调度. 每个作业只调入一次调出一次. 作业调入时会建立相应的PCB, 作业调出时次啊撤销PCB. </li>
<li>高级调度主要指调入的问题(系统确定调入时机)</li>
</ul>
</li>
<li>中级调度(内存调度)<ul>
<li>引入虚拟存储技术后, 可暂时不能运行的进程调值外存等待, 等它重新具备了运行条件, 且内存有空闲时, 在重新调入内存</li>
<li>这么做的目的是为了 提高内存利用率 和 系统吞吐量</li>
<li>调到外存的的进程状态 挂起装填, PCB并不会一起调到外存, 而是常驻内存. PCB会记录进程数据在外存中的位置,进程状态等信息, 系统会通过内存中的PCB来保持对各个进程的监控,管理. 被挂起的进程PCB会放到 挂起队列中</li>
<li>中级调度, 决定将那个挂起状态的进程重新调入内存, 一个进程可能会被多次调出,调入内存. 因此中继调度的频率比高级多</li>
</ul>
</li>
<li>补充 : 进程的挂起状态与七状态模型<ul>
<li>挂起状态 挂起态 suspend<ul>
<li>暂时调到外存等待的进程状态</li>
<li>就绪挂起</li>
<li>阻塞挂起</li>
</ul>
</li>
<li>五装填 -&gt; 七状态<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107163438119.png" alt="image-20230107163438119"></li>
</ul>
</li>
</ul>
</li>
<li>低级调度(进程调度)<ul>
<li>按照某种方法和策略从就绪队列中选取一个进程,将处理机分配</li>
<li>最基本的调度, 一般操作系统中必须配置进程调度</li>
<li>频率很高 一般几十毫秒一次</li>
</ul>
</li>
</ul>
</li>
<li>对比<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107181411033.png" alt="image-20230107181411033"></li>
</ul>
</li>
</ul>
<h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107181441644.png" alt="image-20230107181441644"></p>
<h3 id="2-2-2-进程调度的时机-切换与过程-方式"><a href="#2-2-2-进程调度的时机-切换与过程-方式" class="headerlink" title="2.2.2 进程调度的时机,切换与过程,方式"></a>2.2.2 进程调度的时机,切换与过程,方式</h3><ul>
<li>进程调度的时机<ul>
<li>按照某种算法从就绪队列中选一个进程分配处理机</li>
<li>需要进程调度与切换的情况<ul>
<li>当前运行的进程主动放弃处理机<ul>
<li>正常终止</li>
<li>发生异常终止</li>
<li>进程主动请求阻塞 等待I&#x2F;O</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事要处理 (I&#x2F;O中断)</li>
<li>更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>不能进行进程调度与切换的情况<ul>
<li>处理中断的过程中. 中断处理过程复杂, 与硬件密切相关, 很难做到中断处理过程中进行进程切换</li>
<li>进程在操作系统内核程序的临界区中</li>
<li>原子操作过程中(原语) 原子操作不可断(如修改PCB中的进程状态标志, 并把PCB放到相应队列)</li>
</ul>
</li>
<li>临界资源<ul>
<li>一个时间段内只允许一个进程使用的资源, 各进程需要互斥地访问临界资源</li>
</ul>
</li>
<li>临界区<ul>
<li>访问临界资源的那段代码</li>
</ul>
</li>
<li>内核程序临界区<ul>
<li>用来访问某种内核数据结构的, 比如进程的就绪队列(各就绪进程的PCB组成)</li>
</ul>
</li>
<li>普通临界区可以进行调度与切换<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107191908575.png" alt="image-20230107191908575"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107191950900.png" alt="image-20230107191950900"></li>
</ul>
</li>
<li>进程调度的方式<ul>
<li>非剥夺调度方式 非抢占方式 允许进程主动放弃处理机, 在运行过程中即便有更紧迫的任务到达, 当前进程依然会继续使用处理机.. 当前进程依然会使用处理机, 知道进程终止或主动要求进入阻塞 <ul>
<li>实现简单, 系统开销小, 但无法法即使处理紧急任务, 适合早期批处理</li>
</ul>
</li>
<li>剥夺调度方式 抢占方式 如果有更紧急的进程, 就立即暂停正在执行的进程,先吧处理机分给更重要紧急的进程<ul>
<li>可以优先处理紧急进程, 也可以实现时间片轮转的功能, 适合分时操作系统, 实时操作系统</li>
</ul>
</li>
</ul>
</li>
<li>进程的切换与过程<ul>
<li>狭义的进程调度 与 进程切换的区别<ul>
<li>狭义进程调度是指, 从就绪队列选一个要运行的进程(可以是刚刚被暂停执行的, 也可以是另一个, 后一种情况就需要进程切换)</li>
<li>进程切换是指一个进程让出处理机, 由另一个进程占用处理机的过程</li>
<li>广义的进程你调度包含了选择一个进程和进程切换两个步骤</li>
</ul>
</li>
<li>进程切换<ul>
<li>对原来运行数据的保存</li>
<li>对新的进程数据进程各种数据的恢复</li>
<li>进程切换是有代价的, 因此频繁进行调度切换会使系统效率降低</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-不是重点-x2F-需要理解"><a href="#小结-不是重点-x2F-需要理解" class="headerlink" title="小结(不是重点&#x2F;需要理解)"></a>小结(不是重点&#x2F;需要理解)</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107200421521.png" alt="image-20230107200421521"></p>
<h3 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2.3 调度算法的评价指标"></a>2.2.3 调度算法的评价指标</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105201610875.png" alt="image-20230105201610875"></p>
<ul>
<li><p>CPU利用率</p>
<ul>
<li>利用率 &#x3D; 忙碌时间&#x2F;总时间</li>
</ul>
</li>
<li><p>系统吞吐量</p>
<ul>
<li>单位时间完成的作业数量</li>
<li>总共完成多少作业&#x2F;总共花了多少时间</li>
</ul>
</li>
<li><p>周转时间</p>
<ul>
<li>从作业提交给系统到作业完成为止的时间间隔<ul>
<li>作业完成时间 - 作业提交时间</li>
</ul>
</li>
<li>平均周转时间 &#x3D; 各个周转时间和&#x2F;作业数</li>
<li>带权周转时间 &#x3D; 作业周转时间&#x2F;作业实际运行时间<ul>
<li>肯定&gt;&#x3D;1</li>
<li>越小越好</li>
</ul>
</li>
<li>平均带权周转时间</li>
</ul>
</li>
<li><p>等待时间</p>
<ul>
<li>指进程处于等待处理机状态时间之和</li>
<li>对于进程来说, 等待时间就是建立后等待被服务的时间总和, 等待I&#x2F;O完成的时间也是在被服务的, 所以不计如等待时间</li>
<li>对于作业来说, 不仅要考虑建立进程后的等待时间, 还要加上作业在外存后备队列中等待的时间</li>
<li>调度算法只回影响作业&#x2F;进程的等待时间 (平均等待时间来评价整体性能)</li>
</ul>
</li>
<li><p>响应时间</p>
<ul>
<li>指从用户提出请求到首次产生相应所用的时间</li>
</ul>
</li>
</ul>
<h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230105203853240.png" alt="image-20230105203853240"></p>
<h3 id="2-2-4-FCFS-SJF-HRRN调度算法"><a href="#2-2-4-FCFS-SJF-HRRN调度算法" class="headerlink" title="2.2.4 FCFS, SJF, HRRN调度算法"></a>2.2.4 FCFS, SJF, HRRN调度算法</h3><ul>
<li><p>Tips</p>
<ul>
<li>饥饿<ul>
<li>某进程&#x2F;作业长期得不到任务</li>
</ul>
</li>
</ul>
</li>
<li><p>先来先服务 FCFS First Come First Serve</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107202525263.png" alt="image-20230107202525263"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230107202819759.png" alt="image-20230107202819759"></li>
</ul>
</li>
<li><p>短作业优先 SJF Shortest Job First</p>
<ul>
<li>非抢占式</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108012022257.png" alt="image-20230108012022257"></li>
<li>抢占式 最短剩余时间算法 SRTN</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108012218296.png" alt="image-20230108012218296"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108022826664.png" alt="image-20230108022826664"></li>
<li>在所有进程(几乎)同时可运行时, SJF的平均等待时间, 周转时间最少</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108023152461.png" alt="image-20230108023152461"></li>
</ul>
</li>
<li><p>高响应比优先 HRRN, Highest Response Ratio Next</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108023652634.png" alt="image-20230108023652634"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108023754066.png" alt="image-20230108023754066"></li>
</ul>
<h4 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108023857877.png" alt="image-20230108023857877"></p>
</li>
</ul>
<h3 id="2-2-5-调度算法-时间片轮转-优先级-多级反馈队列"><a href="#2-2-5-调度算法-时间片轮转-优先级-多级反馈队列" class="headerlink" title="2.2.5 调度算法:时间片轮转, 优先级, 多级反馈队列"></a>2.2.5 调度算法:时间片轮转, 优先级, 多级反馈队列</h3><ul>
<li>时间片轮转 RR Round-Robin (抢占式)<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025005855.png" alt="image-20230108025005855"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025054866.png" alt="image-20230108025054866"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025108274.png" alt="image-20230108025108274"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025118920.png" alt="image-20230108025118920"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025137258.png" alt="image-20230108025137258"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025143279.png" alt="image-20230108025143279"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108025201077.png" alt="image-20230108025201077"></li>
<li>如果时间片太大, 则会退化为FCFS调度算法, 且会增大进程相应时间</li>
<li>进程调度是有时间代价的(保存恢复运行环境) 如果时间片你太小, 会导致进程切换过于频繁, 导致实际用于执行的时间减少, 因此时间片也不能太小</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108031819408.png" alt="image-20230108031819408"></li>
</ul>
</li>
<li>优先级调度算法(抢占式)<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108032000845.png" alt="image-20230108032000845"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108032105845.png" alt="image-20230108032105845"></li>
<li>优先级<ul>
<li>静态优先级</li>
<li>动态优先级<ul>
<li>追求公平, 提升资源利用率</li>
<li>等待时间长, 适当提高优先级</li>
<li>占用处理机运行很长时间, 适当降低优先级</li>
<li>频繁进行I&#x2F;O操作, 适当提高优先级</li>
</ul>
</li>
<li>系统进程高于用户进程</li>
<li>前台 高于 后台 </li>
<li>操作系统更偏好I&#x2F;O进程 (与I&#x2F;O相对的是计算型进程)&#x2F;CPU繁忙型进程<ul>
<li>I&#x2F;O设备和CPU可以并行工作. 如果优先让I&#x2F;O繁忙型进程优先运行的话, 则越有可能让I&#x2F;O设备今早地投入工作, 资源利用率, 系统吞吐量都会得到提升</li>
</ul>
</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108034108113.png" alt="image-20230108034108113"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108034137126.png" alt="image-20230108034137126"></li>
</ul>
</li>
<li>多级队列调度算法 (抢占式) (实际实现有可能是非抢占)<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108035725638.png" alt="image-20230108035725638"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108035942688.png" alt="image-20230108035942688"></li>
</ul>
</li>
</ul>
<h4 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230108040037993.png" alt="image-20230108040037993"></p>
<h3 id="2-3-1-进程同步-进程互斥"><a href="#2-3-1-进程同步-进程互斥" class="headerlink" title="2.3.1 进程同步, 进程互斥"></a>2.3.1 进程同步, 进程互斥</h3><blockquote>
<p>知识点回顾: 异步性: 各并发执行的进程以各自独立的, 不可预知的速度向前推进.</p>
</blockquote>
<ul>
<li><p>进程同步</p>
<ul>
<li>进程同步就是解决异步的问题</li>
<li>同步 直接制约关系, 指为完成某种任务而建立的两个或多个进程, 这些进程因为需要在某些位置上协调他们的工作次序而产生制约关系. 进程间的直接制约关系是源于他之间的相互合作(写数据在前, 读数据在后)</li>
</ul>
</li>
<li><p>进程互斥</p>
<ul>
<li><blockquote>
<p>进程的并发需要共享的支持, </p>
</blockquote>
</li>
<li><p>临界资源</p>
<ul>
<li>一个时间段内只允许一个进程使用的资源</li>
</ul>
</li>
<li><p>对临界资源的访问, 必须互斥地进行. 互斥, 亦称间接制约关系. </p>
</li>
<li><p>进程互斥</p>
<ul>
<li>当一个进程访问某临界资源时, 另一个想访问该资源的进程必须等待</li>
</ul>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109033601205.png" alt="image-20230109033601205"></p>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109033608785.png" alt="image-20230109033608785"></p>
</li>
<li><p>需要遵循的原则</p>
<ul>
<li>空闲让进<ul>
<li>临界区空闲时, 可以允许一个请求进入临界区的进程立即进入</li>
</ul>
</li>
<li>忙则等待<ul>
<li>当已有进程进入临界区时, 其他试图进入的进程必须等待</li>
</ul>
</li>
<li>有限等待<ul>
<li>对请求访问的进程, 应保证能在有限时间内进入临界区(保证不饥饿)</li>
</ul>
</li>
<li>让权等待<ul>
<li>当进程不能进入临界区时, 应立即释放处理机, 防止进程忙等待</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109034158531.png" alt="image-20230109034158531"></p>
<h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3.2 进程互斥的软件实现方法"></a>2.3.2 进程互斥的软件实现方法</h3><ul>
<li>单标志法<ul>
<li>每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程, 也就是说每个进程进入临界区的权限只能憋另一个进程赋予</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109034629721.png" alt="image-20230109034629721"></li>
<li>违背空闲让进 规则</li>
</ul>
</li>
<li>双标志先检查法<ul>
<li>设置一个布尔数组, 数组各个元素用来标记个进程进入临界区的意愿,每个进程进入临界区前, 先检查, 有没有别的进程想进入临界区. 如果没有, 把自身对应标志 flag[i] 设为 true, 之后开始访问临界区</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109041258422.png" alt="image-20230109041258422"></li>
<li>违背 忙则等待原则</li>
<li>原因在于 进入区的检查和上锁 两个处理不是一气呵成的</li>
</ul>
</li>
<li>双标志后检查法<ul>
<li>先上锁, 后检查</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109041436799.png" alt="image-20230109041436799"></li>
<li>违背了 空闲让进, 有限等待 会产生饥饿现象</li>
</ul>
</li>
<li>Peterson算法<ul>
<li>让进程尝试让对方先试用</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109041924759.png" alt="image-20230109041924759"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109042102462.png" alt="image-20230109042102462"></li>
<li>解决了 空闲等待, 忙则等待, 有限等待 三个原则</li>
<li>违反了 让权等待</li>
</ul>
</li>
</ul>
<h4 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109042228544.png" alt="image-20230109042228544"></p>
<h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3.3 进程互斥的硬件实现方法"></a>2.3.3 进程互斥的硬件实现方法</h3><ul>
<li><p>中断屏蔽方法</p>
<ul>
<li>利用开关中断指令实现(与原语相同, 在某进程开始访问临界区到结束访问为止, 都不允许被中断, 也就不能发生进程切换, 因此不可能出现两个同时访问临界区的情况 )</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109042907220.png" alt="image-20230109042907220"></li>
<li>优点<ul>
<li>简单, 高效</li>
</ul>
</li>
<li>缺点<ul>
<li>不适用于多处理机, 只适用于操作系统内核进程, 不适合用户进程(中断只能运行在核心态)</li>
</ul>
</li>
</ul>
</li>
<li><p>TestAndSet(TS指令) &#x2F; TestAndSetLock(TSL指令)</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109045435248.png" alt="image-20230109045435248"></li>
<li>能保证检查和上锁一起合成</li>
<li>优点<ul>
<li>实现简单, 无逻辑漏洞, 适合多处理机</li>
</ul>
</li>
<li>缺点<ul>
<li>不满足让权等待, 暂时无法进入临界区的进程会占用CPU并循环执行TSL指令, 导致忙等</li>
</ul>
</li>
</ul>
</li>
<li><p>Swap 指令</p>
<ul>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109045739752.png" alt="image-20230109045739752"></p>
</li>
<li><p>同TSL&#x2F;TR</p>
</li>
</ul>
</li>
</ul>
<h4 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109045842163.png" alt="image-20230109045842163"></p>
<h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3.4 信号量机制"></a>2.3.4 信号量机制</h3><ul>
<li>解决上述几种解决进程互斥问题的方案</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109050806463.png" alt="image-20230109050806463"></li>
<li>整形信号量<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109051117235.png" alt="image-20230109051117235"></li>
</ul>
</li>
<li>记录型信号量<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109051320253.png" alt="image-20230109051320253"></li>
<li>例子讲解 见 视频</li>
<li>解决了 让权等待</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109051845977.png" alt="image-20230109051845977"></li>
</ul>
</li>
</ul>
<h4 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109051934374.png" alt="image-20230109051934374"></p>
<h3 id="2-3-5-用信号量实现进程互斥-同步-前驱关系"><a href="#2-3-5-用信号量实现进程互斥-同步-前驱关系" class="headerlink" title="2.3.5 用信号量实现进程互斥, 同步, 前驱关系"></a>2.3.5 用信号量实现进程互斥, 同步, 前驱关系</h3><ul>
<li>信号量机制实现进程互斥<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109145607148.png" alt="image-20230109145607148"></li>
</ul>
</li>
<li>信号量机制实现进程同步<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109160753081.png" alt="image-20230109160753081"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109161542627.png" alt="image-20230109161542627"></li>
</ul>
</li>
<li>信号量机制实现前驱关系<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109181759860.png" alt="image-20230109181759860"></li>
</ul>
</li>
</ul>
<h4 id="小结-18"><a href="#小结-18" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109181907980.png" alt="image-20230109181907980"></p>
<h3 id="2-3-6-生产者-消费者问题"><a href="#2-3-6-生产者-消费者问题" class="headerlink" title="2.3.6 生产者-消费者问题"></a>2.3.6 生产者-消费者问题</h3><ul>
<li>问题描述<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109182247230.png" alt="image-20230109182247230"></li>
</ul>
</li>
<li>问题分析<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109182637098.png" alt="image-20230109182637098"></li>
<li><ol start="3">
<li>设置信号量, 并确定初值</li>
</ol>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109182759631.png" alt="image-20230109182759631"></li>
</ul>
</li>
<li>如何实现<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109183019256.png" alt="image-20230109183019256"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109183124938.png" alt="image-20230109183124938"></li>
</ul>
</li>
</ul>
<h4 id="小结-19"><a href="#小结-19" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109183410325.png" alt="image-20230109183410325"></p>
<h3 id="2-3-7-多生产者-多消费之问题-多类"><a href="#2-3-7-多生产者-多消费之问题-多类" class="headerlink" title="2.3.7 多生产者-多消费之问题 (多类)"></a>2.3.7 多生产者-多消费之问题 (多类)</h3><ul>
<li>问题描述<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109184253232.png" alt="image-20230109184253232"></li>
</ul>
</li>
<li>问题分析<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109184744037.png" alt="image-20230109184744037"></li>
</ul>
</li>
<li>如何实现<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109190513794.png" alt="image-20230109190513794"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109190538656.png" alt="image-20230109190538656"></li>
</ul>
</li>
</ul>
<h4 id="小结-20"><a href="#小结-20" class="headerlink" title="小结"></a>小结</h4><p> <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109191126141.png" alt="image-20230109191126141"></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109191253828.png" alt="image-20230109191253828"></p>
<h3 id="2-3-8-吸烟者问题-1对多"><a href="#2-3-8-吸烟者问题-1对多" class="headerlink" title="2.3.8 吸烟者问题(1对多)"></a>2.3.8 吸烟者问题(1对多)</h3><ul>
<li>问题描述<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109203124156.png" alt="image-20230109203124156"></li>
</ul>
</li>
<li>问题分析<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109203310756.png" alt="image-20230109203310756"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109203415543.png" alt="image-20230109203415543"></li>
</ul>
</li>
<li>如何实现<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109233958891.png" alt="image-20230109233958891"></li>
</ul>
</li>
</ul>
<h4 id="小结-21"><a href="#小结-21" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109234101228.png" alt="image-20230109234101228"></p>
<h3 id="2-3-9-读者-写者问题-读文件是不会对文件产生影响-因此可以并行"><a href="#2-3-9-读者-写者问题-读文件是不会对文件产生影响-因此可以并行" class="headerlink" title="2.3.9 读者-写者问题 (读文件是不会对文件产生影响, 因此可以并行)"></a>2.3.9 读者-写者问题 (读文件是不会对文件产生影响, 因此可以并行)</h3><ul>
<li>问题描述<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109234954647.png" alt="image-20230109234954647"></li>
</ul>
</li>
<li>问题分析<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109235241744.png" alt="image-20230109235241744"></li>
</ul>
</li>
<li>如何实现<ul>
<li>读 优先<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230109235850049.png" alt="image-20230109235850049"></li>
</ul>
</li>
<li>读写公平<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111070021037.png" alt="image-20230111070021037"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-22"><a href="#小结-22" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111070300474.png" alt="image-20230111070300474"></p>
<h3 id="2-3-10-哲学家进餐问题-一个进程需要多个临界资源时"><a href="#2-3-10-哲学家进餐问题-一个进程需要多个临界资源时" class="headerlink" title="2.3.10 哲学家进餐问题(一个进程需要多个临界资源时)"></a>2.3.10 哲学家进餐问题(一个进程需要多个临界资源时)</h3><ul>
<li><p>问题描述</p>
<ul>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111070521381.png" alt="image-20230111070521381"></p>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111070635446.png" alt="image-20230111070635446"></p>
</li>
<li><p>避免死锁</p>
<ul>
<li>最多能允许4个哲学家同时进餐, 这样可以保证至少一个哲学家可以拿到两个</li>
<li>要求奇数号哲学家先拿左边的, 然后拿右边的, 可以保证相邻的两个奇偶哲学家都想吃饭, 那么其中一个拿起一只就可以拿起另一只, 另一个哲学家会阻塞</li>
<li>仅当一个这也加左右两只筷子都可用时才允许抓筷子</li>
</ul>
</li>
</ul>
</li>
<li><p>如何实现</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111152047451.png" alt="image-20230111152047451"></li>
<li>不会锁死, 但会导致卡顿?</li>
</ul>
</li>
</ul>
<h4 id="小结-23"><a href="#小结-23" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111152203946.png" alt="image-20230111152203946"></p>
<h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3.11 管程"></a>2.3.11 管程</h3><ul>
<li><p>为什么引入管程</p>
<ul>
<li>信号量机制问题<ul>
<li>编写控制困难</li>
<li>易出错</li>
</ul>
</li>
</ul>
</li>
<li><p>管程</p>
<ul>
<li>一种高级同步机制</li>
<li>1973年首次在pascal中引入</li>
</ul>
</li>
<li><p>管程的定义和基本特征</p>
<ul>
<li><p>作为特殊的软件模块,由这些部分组成</p>
<ul>
<li>局部于管程的共享数据结构说明</li>
<li>对数据结构进行操作的一组过程 (过程就是函数)</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程有一个名字</li>
</ul>
</li>
<li><p>管程的基本特征</p>
<ul>
<li>局部于管程的数据只能被局部于管程的过程访问\</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程给只允许管程内执行某个过程</li>
</ul>
</li>
</ul>
</li>
<li><p>拓展1: 管程解决 生产者 - 消费者问题</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111155613116.png" alt="image-20230111155613116"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111160002324.png" alt="image-20230111160002324"></li>
</ul>
</li>
<li><p>拓展2: JAVA 中类似管程的机制</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111160055242.png" alt="image-20230111160055242"></li>
</ul>
</li>
</ul>
<h4 id="小结-24"><a href="#小结-24" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111160131855-3413292.png" alt="image-20230111160131855"></p>
<h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h3><ul>
<li>什么是死锁<ul>
<li>并发环境下, 各进程因竞争资源造成的一种 互相等待对方的资源, 导致各进程都阻塞, 都无妨向前推进.</li>
<li>发生死锁后无外力干涉, 就无法向前推进</li>
</ul>
</li>
<li>死锁, 饥饿, 死循环<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111163850037.png" alt="image-20230111163850037"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111163901251.png" alt="image-20230111163901251"></li>
</ul>
</li>
<li>死锁产生的必要条件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111164209000.png" alt="image-20230111164209000"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111164318121.png" alt="image-20230111164318121"></li>
</ul>
</li>
<li>什么时候会发生死锁<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111164430993.png" alt="image-20230111164430993"></li>
</ul>
</li>
<li>死锁处理策略<ul>
<li>预防死锁 破坏死锁产生的四个必要条件的一个或多个</li>
<li>避免死锁 用某种方法组织系统进入不安全状态, 从而比年死锁(银行算法)</li>
<li>死锁的检测和解除 允许死锁发生, 不过操作系统会负责检测并解除</li>
</ul>
</li>
</ul>
<h4 id="小结-25"><a href="#小结-25" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111164653531.png" alt="image-20230111164653531"></p>
<h3 id="2-4-2-死锁的处理策略-预防死锁"><a href="#2-4-2-死锁的处理策略-预防死锁" class="headerlink" title="2.4.2 死锁的处理策略 - 预防死锁"></a>2.4.2 死锁的处理策略 - 预防死锁</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111164716401.png" alt="image-20230111164716401"></p>
<ul>
<li>破坏互斥条件<ul>
<li>互斥条件<ul>
<li>只有对必须互斥使用的资源的争抢,才会导致死锁</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111164900960.png" alt="image-20230111164900960"></li>
<li>缺点<ul>
<li>并不是所有资源都可以改造成可共享使用的资源, 为了系统安全, 很多地方必须保护这种互斥性. 因此, 很多时候无法破坏互斥条件</li>
</ul>
</li>
</ul>
</li>
<li>破坏不剥夺条件<ul>
<li>不剥夺条件<ul>
<li>进程所获得资源未使用完前, 不能被其他进程抢夺, 只能主动释放</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111165053032.png" alt="image-20230111165053032"></li>
<li>缺点<ul>
<li>实现复杂</li>
<li>释放已获得资源会导致前一阶段工作实效, 因此一般只适于已保存和恢复状态的资源 如 CPU</li>
<li>反复申请和释放, 会增加系统开销, 降低系统吞吐量</li>
<li>采用方案1, 意味着只要暂时得不到某个资源, 之前获得的就都要放弃, 以后重新申请, 如果一直发生这样的情况,就会导致进程饥饿</li>
</ul>
</li>
</ul>
</li>
<li>破坏请求和保持条件<ul>
<li>请求和保持条件<ul>
<li>进程已经保持了至少一个资源, 但又提出新的资源请求, 而该资源又被其他进程占有, 此时请求进程被阻塞, 但又对自己已有的资源保持不放</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111171117448.png" alt="image-20230111171117448"></li>
</ul>
</li>
<li>破坏循环等待条件<ul>
<li>循环等待条件<ul>
<li>存在一种进程资源的循环等待链, 链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111171603534.png" alt="image-20230111171603534"></li>
</ul>
</li>
</ul>
<h4 id="小结-26"><a href="#小结-26" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111171651111.png" alt="image-20230111171651111"></p>
<h3 id="2-4-3-死锁的处理策略-避免死锁"><a href="#2-4-3-死锁的处理策略-避免死锁" class="headerlink" title="2.4.3 死锁的处理策略 - 避免死锁"></a>2.4.3 死锁的处理策略 - 避免死锁</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111190914362.png" alt="image-20230111190914362"></p>
<ul>
<li>什么是安全序列<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111191230984.png" alt="image-20230111191230984"></li>
</ul>
</li>
<li>安全序列, 不安全状态, 死锁的联系<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111191337048.png" alt="image-20230111191337048"></li>
<li>安全序列<ul>
<li>指如果系统按照这种序列分配资源, 则每个进程都能顺利完成, 只要找到一个安全序列, 系统就是安全状态, 安全序列存在多个</li>
</ul>
</li>
<li>不安全状态<ul>
<li>分配资源后找不到安全序列, 就进入不安全状态, 所有进程都可能无法执行下去.</li>
</ul>
</li>
<li>与死锁的联系<ul>
<li>处于安全状态 一定不会发生死锁, 进入不安全状态, 可能发生死锁.</li>
<li>不安全状态未必发生死锁, 死锁一定在不安全状态下</li>
</ul>
</li>
</ul>
</li>
<li>银行家算法<ul>
<li>Dijkstra 为银行系统设计.后用于操作系统, 避免死锁</li>
<li>在进程提出资源申请时, 先判断此次分配是否会导致系统进入不安全状态. 如果会进入不安全, 就先不答应这次请求, 先让进程阻塞等待</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111193411787.png" alt="image-20230111193411787"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111193451749.png" alt="image-20230111193451749"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111193509917.png" alt="image-20230111193509917"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111193647121.png" alt="image-20230111193647121"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111194247173.png" alt="image-20230111194247173"></li>
</ul>
</li>
</ul>
<h4 id="小结-27"><a href="#小结-27" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111194410362.png" alt="image-20230111194410362"></p>
<h3 id="2-4-4-死锁的处理策略-检测和解除"><a href="#2-4-4-死锁的处理策略-检测和解除" class="headerlink" title="2.4.4 死锁的处理策略 - 检测和解除"></a>2.4.4 死锁的处理策略 - 检测和解除</h3><ul>
<li>死锁的检测<ul>
<li>用某种数据结构来保存资源的请求和分配信息</li>
<li>提供一种算法, 利用上述信息来检测系统是否进入死锁状态</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111194736932.png" alt="image-20230111194736932"></li>
<li>如果能够最终消除所有边,则称这个图是可完全简化的, 此时一定没有发生死锁</li>
<li>最终不能消除所有边, 就发生了死锁</li>
<li>最后 还连着编的就是死锁的进程</li>
<li>检测死锁的算法<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111200044758.png" alt="image-20230111200044758"></li>
</ul>
</li>
</ul>
</li>
<li>死锁的解除<ul>
<li>一旦检测到死锁, 就立即解除</li>
<li>花间资源分配图后, 还连着边的进程就是死锁进程</li>
<li>主要方法<ul>
<li>资源剥夺法 <ul>
<li>挂起(暂时放到外存)死锁进程, 抢占其资源, 分配给其他死锁进程, 当应放置被挂起长时间得不到资源饥饿</li>
</ul>
</li>
<li>撤销进程法(终止进程法) <ul>
<li>前置撤销部分甚至全部死锁进程,并剥夺资源,有点事实现简单, 缺点是代价很大</li>
</ul>
</li>
<li>进程回退法<ul>
<li>让一个或多个死锁进程回退到足以避免死锁的地步. 要求系统记录进程的历史信息, 设置还原点</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111202450228.png" alt="image-20230111202450228"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-28"><a href="#小结-28" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111202528292.png" alt="image-20230111202528292"></p>
<h3 id="3-1-1-内存的基础知识"><a href="#3-1-1-内存的基础知识" class="headerlink" title="3.1.1 内存的基础知识"></a>3.1.1 内存的基础知识</h3><ul>
<li>什么会是内存, 有何作用<ul>
<li>内存是存放数据的硬件. 程序执行前需要先放到内存中才能被CPU处理</li>
<li>存储单元<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111202809573.png" alt="image-20230111202809573"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111202911805.png" alt="image-20230111202911805"></li>
</ul>
</li>
</ul>
</li>
<li>进程的运行原理–指令<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111203031467.png" alt="image-20230111203031467"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111203136801.png" alt="image-20230111203136801"></li>
</ul>
</li>
<li>逻辑地址 vs 物理地址<ul>
<li>相对地址 vs 绝对地址</li>
</ul>
</li>
<li>从写程序到程序运行<ul>
<li>​	<img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230111212747556.png" alt="image-20230111212747556"></li>
<li>编译<ul>
<li>将源代码编译成若干个目标模块</li>
<li>把高级语言翻译成机器语言</li>
</ul>
</li>
<li>链接<ul>
<li>将编译后形成的一组目标模块以及所需的函数链接在一起, 形成一个完整的装入模块</li>
</ul>
</li>
<li>装入(装载)<ul>
<li>有装入程序将装入模块装入内存运行</li>
</ul>
</li>
</ul>
</li>
<li>装入模块装入内存<ul>
<li>绝对装入<ul>
<li>在编译时, 如果知道程序放到内存中哪个位置, 编译程序,将产生绝对地址的目标代码. 装入程序按照装入模块中的地址, 将程序和数据装入内存</li>
<li>只使用与单道程序环境</li>
</ul>
</li>
<li>静态重定位<ul>
<li>可重定位装入</li>
<li>编译链接后的装入模块的地址是从0开始的, 指令中使用的存放地址,数据存放的地址都是相对起始地址而言的逻辑地址, 可根据内存的当前撞款,将装入模块装入到内存的适当地址, 装入是对地址进行重定位, 将逻辑地址变为物理地址</li>
<li>在作业装入内存时, 必须分配器需求的全部内存空间, 如果没有足够内存,则不能装入该作业. 作业一旦进入内存后, 在运行期间就不能移动, 也不能再申请内存空间.</li>
</ul>
</li>
<li>动态重定位<ul>
<li>动态运行时装入</li>
<li>编译链接后的装入模块的地址都是从0开始的. 装入程序把装入内存后, 并不会立即把逻辑地址转换为物理地址, 而是吧地址转换推迟到程序真正执行时才进行. 因此装入内存后所有的地址依然是逻辑地址,这种方式需要一个重定位寄存器的支持</li>
<li>允许程序在内存中发生移动</li>
</ul>
</li>
</ul>
</li>
<li>链接的三种方式<ul>
<li>静态链接<ul>
<li>运行前, 现将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块), 之后不在拆开</li>
</ul>
</li>
<li>装入时动态链接<ul>
<li>将个目标模块装入内存时, 边装入边链接</li>
</ul>
</li>
<li>运行时动态链接:<ul>
<li>在执行中需要该目标模块时, 才对它进行链接, 优点是便于修改和更新, 便于实现对目标模块的共享</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-29"><a href="#小结-29" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230112002600663.png" alt="image-20230112002600663"></p>
<h3 id="3-1-2-内存管理的概念"><a href="#3-1-2-内存管理的概念" class="headerlink" title="3.1.2 内存管理的概念"></a>3.1.2 内存管理的概念</h3><ul>
<li>内存空间的分配与回收<ul>
<li>操作系统负责内存空间的分配与回收</li>
<li>操作系统需要提供某种技术,逻辑上对呢存空间进行扩充 </li>
<li>操作系统需要提供地址转换功能, 负责程序的逻辑地址与物理地址的转换<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230112002903418.png" alt="image-20230112002903418"></li>
</ul>
</li>
<li>操作系统需要提供内存保护功能, 保证各进程在各自存储空间内运行, 互不干扰</li>
<li>虚拟技术(操作系统的虚拟性)</li>
</ul>
</li>
<li>内存保护<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230112004200647.png" alt="image-20230112004200647"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230112004246832.png" alt="image-20230112004246832"></li>
</ul>
</li>
</ul>
<h4 id="小结-30"><a href="#小结-30" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230112004334607.png" alt="image-20230112004334607"></p>
<h3 id="3-1-3-覆盖与交换"><a href="#3-1-3-覆盖与交换" class="headerlink" title="3.1.3 覆盖与交换"></a>3.1.3 覆盖与交换</h3><ul>
<li>覆盖技术<ul>
<li>将程序分成多个段(多个模块). 常用的段常驻内存, 不常用的段在需要时调入内存</li>
<li>解决程序大小超过物理内存总和的问题</li>
<li>分为 一个 固定区, 和若干个 覆盖区</li>
<li>常驻内存的段放在 固定区, 调入后就不在调出(除非运行结束)</li>
<li>不常用的放在 覆盖区, 需要用时调入内存, 用不到时调出内存</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113013436539.png" alt="image-20230113013436539"></li>
<li>必须由程序员声明覆盖结构, 操作系统完成自动覆盖, 缺点, 增加用户编程负担</li>
<li>只用于早期操作系统中</li>
</ul>
</li>
<li>交换(对换)技术 [中级调度]<ul>
<li><p>内存空间紧张时, 系统将内存中某些进程暂时换出外存, 把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p>
</li>
<li><p>中级调度(内存调度) 就是决定将那个处于挂起状态的进程重新调入内存</p>
</li>
<li><p>暂时换出外存等待的进程状态为挂起状态(挂起态, suspend)</p>
<ul>
<li>就绪挂起 </li>
<li>阻塞挂起</li>
</ul>
</li>
<li><p>具有对换功能的操作系统, 磁盘空间分为文件区和对换区.</p>
<ul>
<li>文件区主要存放文件, 最求存储空间的利用率, 因此文件区空间的管理采用离散分配方式</li>
<li>对换区只占用一小部分, 被换出的进程数据就存放在对换区. 要求, 换入换出速度. 因此兑换区采用连续分配方式</li>
<li>对换区的I&#x2F;O速度比文件区快</li>
</ul>
</li>
<li><p>交换通常在内存紧张时进行, 系统负荷降低就暂停</p>
</li>
<li><p>优先换出阻塞进程, 优先级低的进程, 为了防止优先级低的进程在被调入内存后又很快被换出, 有点系统还会考虑进程在内存的驻留时间</p>
</li>
<li><p>PCB常驻内存</p>
</li>
</ul>
</li>
</ul>
<h4 id="小结-31"><a href="#小结-31" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113021148838.png" alt="image-20230113021148838"></p>
<h3 id="3-1-4-连续分配管理方式"><a href="#3-1-4-连续分配管理方式" class="headerlink" title="3.1.4 连续分配管理方式"></a>3.1.4 连续分配管理方式</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113023921883.png" alt="image-20230113023921883"></p>
<ul>
<li>单一连续分配<ul>
<li>系统区<ul>
<li>处于内存低地址部分, 存放操作系统相关数据</li>
</ul>
</li>
<li>用户区<ul>
<li>存放用户进程相关数据, 内存只能有一到用户程序, 用户程序独占整个用户区空间</li>
</ul>
</li>
<li>优点, 实现简单, 无外部碎片. 可采用覆盖技术扩充内存, 不一定采用内存保护</li>
<li>缺点, 只能用于单用户, 单的任务, 有内部碎片, 存储器利用率低</li>
</ul>
</li>
<li>固定分区分配<ul>
<li>将用户空间分为若干固定大小分区, 每个分区只装一道作业</li>
<li>分区大小相等<ul>
<li>缺乏灵活性, 但时候用于一台计算机控制多个相同对象的场合</li>
</ul>
</li>
<li>分区大小不等<ul>
<li>增加灵活性,可满足不同大小的进程需求.</li>
</ul>
</li>
<li>分区说明表<ul>
<li>实现各个分区的分配与回收</li>
<li>大小</li>
<li>起始地址</li>
<li>状态</li>
</ul>
</li>
<li>优点<ul>
<li>实现简单, 无外部碎片</li>
</ul>
</li>
<li>缺点<ul>
<li>当程序太大, 需要采取覆盖技术, 但会降低性能</li>
<li>会产生内部碎片</li>
</ul>
</li>
</ul>
</li>
<li>动态分区分配 (可变分区分配)<ul>
<li>不予先划分内存分区, 根据装入内存的进程大小, 动态建立分区, 使分区大小正好适合进程需要</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113025845764.png" alt="image-20230113025845764"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113025937930.png" alt="image-20230113025937930"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113030110312.png" alt="image-20230113030110312"><ul>
<li>如何分配<ul>
<li>分区有剩余, 直接改变分区大小和起始地址	</li>
<li>分区无剩余, 从表中删除</li>
</ul>
</li>
<li>如何回收<ul>
<li>回收区后有一个相邻空闲分区, 更新分区大小和起始地址 (合并)</li>
<li>回收区前有一个相邻空闲分区, 更新分区大小 </li>
<li>回收区前后各有一个相邻空闲分区, 更新分区大小和起始地址 (合并)</li>
<li>前后都没有, 直接增加一个</li>
</ul>
</li>
<li>动态分区没有内部碎片, 但有外部碎片<ul>
<li>内部碎片 分配给某进程的内存区域中, 部分没用上</li>
<li>外部碎片 内存中某些空闲分区太小难以利用<ul>
<li>紧凑可解决外部碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-32"><a href="#小结-32" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113031727695.png" alt="image-20230113031727695"></p>
<h3 id="3-1-5-动态分区分配算法"><a href="#3-1-5-动态分区分配算法" class="headerlink" title="3.1.5 动态分区分配算法"></a>3.1.5 动态分区分配算法</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113033121213.png" alt="image-20230113033121213"></p>
<ul>
<li>首次适应算法 First Fit<ul>
<li>每次都从低地址开始查找,找到第一个能满足大小的空闲分区</li>
</ul>
</li>
<li>最佳适应算法 Best Fit<ul>
<li>尽可能留下大片空闲区, 优先使用更小的空闲区</li>
<li>空间分区按容量大小递增次序链接. 每次分配内存时顺序查找空闲分区链(分区表)找到大小能满足的第一个空闲分区</li>
<li>缺点<ul>
<li>每次选最小分区进行分配, 会留下越来越多的, 很小的难以利用的内存块, 因此, 这种方法会产生很多的外部碎片</li>
</ul>
</li>
</ul>
</li>
<li>最坏适应算法 Worst Fit (最大适应算法 Largest)<ul>
<li>思路和最佳的相反, 优先最大空闲区分配</li>
<li>空间分区按容量大小递减次序链接</li>
<li>缺点<ul>
<li>最后可能会有 大进程 无处可用</li>
</ul>
</li>
</ul>
</li>
<li>邻近适应算法 Next Fit<ul>
<li>首次适应是从链头开始查找, 可能导致低地址部分出现很多小空闲分区, 而每次查找时, 都要经过这些分区 ,增加了开销, 如果每次从上次查找结束的位置开始检索能解决该问题</li>
<li>以地址递增顺序排列(可排成一个循环链表) 每次从上次查找结束为止开始查找空闲分区链&#x2F;表. 找到能满足要求的第一个分区</li>
<li>缺点<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113145835184.png" alt="image-20230113145835184"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-33"><a href="#小结-33" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113145910382.png" alt="image-20230113145910382"></p>
<h3 id="3-1-6-基本分页存储管理的基本概念"><a href="#3-1-6-基本分页存储管理的基本概念" class="headerlink" title="3.1.6 基本分页存储管理的基本概念"></a>3.1.6 基本分页存储管理的基本概念</h3><ul>
<li>连续分配的缺点<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113150304473.png" alt="image-20230113150304473"></li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113150328720.png" alt="image-20230113150328720"></li>
<li>基本分页存储管理的思想<ul>
<li>把内存分为一个个相等的小分区, 在按照分区大小把进程拆分为一个个小部分</li>
</ul>
</li>
<li>分页存储管理的基本概念<ul>
<li>将内存分为大小相等的分区, 每个分区一个 页框(页帧, 内存块, 物理块). 每个页框有一个编号, 页框号(页帧号, 内存块号, 物理块号) 页框号从0开始</li>
<li>将用户进程的地址空间也分为与页框大小相等的一个个区域, 称为页或页面, 每个页面也有一个编号, 即页号, 从0开始<ul>
<li>最后一个页面可能没有一个页框那么大, 因此页框不能太大, 否则可能产生过大内部碎片</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113154222811.png" alt="image-20230113154222811"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113154311669.png" alt="image-20230113154311669"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113160458629.png" alt="image-20230113160458629"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113160520248.png" alt="image-20230113160520248"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113160629408.png" alt="image-20230113160629408"></li>
</ul>
</li>
<li>页表<ul>
<li>为了知道进程的每个页面在内存中存放的位置, 操作系统要为每一个进程建立张页表</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113163100021.png" alt="image-20230113163100021"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113164536106.png" alt="image-20230113164536106"></li>
</ul>
</li>
</ul>
<h4 id="小结-34"><a href="#小结-34" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113164710964.png" alt="image-20230113164710964"></p>
<h3 id="3-1-7-基本地址变换机构"><a href="#3-1-7-基本地址变换机构" class="headerlink" title="3.1.7 基本地址变换机构"></a>3.1.7 基本地址变换机构</h3><ul>
<li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址</li>
<li>通常会在系统中设置一个页表寄存器 PTR 存放页表在内存中的起始地址F和页表长度M.</li>
<li>进程未执行是, 页表的始址 和 页表长度 放在进程控制块中(PCB)  当进程被调度时, 操作系统内核会将他们放到页表寄存器中</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113193649926.png" alt="image-20230113193649926"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113193818179.png" alt="image-20230113193818179"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113193827756.png" alt="image-20230113193827756"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113202619454.png" alt="image-20230113202619454"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113202807409.png" alt="image-20230113202807409"></li>
</ul>
<h4 id="小结-35"><a href="#小结-35" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113202946282.png" alt="image-20230113202946282"></p>
<h3 id="3-1-8-具有快表的地址交换机构"><a href="#3-1-8-具有快表的地址交换机构" class="headerlink" title="3.1.8 具有快表的地址交换机构"></a>3.1.8 具有快表的地址交换机构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113203005054.png" alt="image-20230113203005054"></p>
<ul>
<li>局部性原理 <ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113203124334.png" alt="image-20230113203124334"></li>
<li>局部性就是说, 如果被访问了一次, 之后很可能会再被访问</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113214829669.png" alt="image-20230113214829669"></li>
</ul>
</li>
<li>快表 TLB<ul>
<li>联想寄存器 TLB 一种访问速度比内存快很多的缓冲存储器, 用来存放当前访问的若干也表项. 与此对应, 内存中页表称为慢表</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230113220516571.png" alt="image-20230113220516571"></li>
<li>地址变换过程<ul>
<li>cpu给出逻辑地址, 由某个硬件算得 页号, 业内偏移量,将页号和快表中所有页号进行比较</li>
<li>如果找到匹配的页号, 直接计算出物理地址 (一次访存)</li>
<li>如果没有, 则访问内存中页表, 计算物理地址. (两次访存) 且将对应页表项存入快表, 若快表已满, 则按照一定的算法对旧页表进行替换</li>
<li>有局部性原理, 快表命中率有90%以上</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114093224836.png" alt="image-20230114093224836"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114093240185.png" alt="image-20230114093240185"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-36"><a href="#小结-36" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114093328447.png" alt="image-20230114093328447"></p>
<h3 id="3-1-9-两级页表"><a href="#3-1-9-两级页表" class="headerlink" title="3.1.9 两级页表"></a>3.1.9 两级页表</h3><ul>
<li>单页表存在的问题<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114185730610.png" alt="image-20230114185730610"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114185755538.png" alt="image-20230114185755538"></li>
<li>问题 1 页表必须连续存放, 因此当页表很大时, 需要占用很多连续的页框</li>
<li>问题 2 没有必要让整个页表常驻内存, 因为进程在一段时间内可能只需要访问某几个特定的页面</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114192627543.png" alt="image-20230114192627543"></li>
</ul>
</li>
<li>两级页表的原理, 地址结构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114193206608.png" alt="image-20230114193206608"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114193333233.png" alt="image-20230114193333233"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114193517612.png" alt="image-20230114193517612"></li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114194425939.png" alt="image-20230114194425939"></li>
</ul>
<h4 id="小结-37"><a href="#小结-37" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114201325470.png" alt="image-20230114201325470"></p>
<h3 id="3-1-10-基本分段存储管理方式"><a href="#3-1-10-基本分段存储管理方式" class="headerlink" title="3.1.10 基本分段存储管理方式"></a>3.1.10 基本分段存储管理方式</h3><p>单位与分页不同</p>
<ul>
<li>分段<ul>
<li>进程的地址空间<ul>
<li>按照程序自身的逻辑关系划分为若干个段, 每个段有一个段名, 每段从0开始编址</li>
</ul>
</li>
<li>内存分配规则<ul>
<li>以段为单位进行分配, 每个段在内存中占据连续空间, 但段之间可以不相邻.</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114204428776.png" alt="image-20230114204428776"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114204908644.png" alt="image-20230114204908644"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114210114020.png" alt="image-20230114210114020"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230114210320318.png" alt="image-20230114210320318"></li>
<li>分段需要检查是否超过段长</li>
</ul>
</li>
<li>分段, 分页管理的对比<ul>
<li>页 是信息的物理单位. 分页的主要目的是为了实现离散分配, 提高内存利用率, 分页仅仅是系统管理上的需要, 完全是系统行为, 对用户不可见</li>
<li>段 是信息的逻辑单位, 分段的主要目的是更好地满足用户需求, 一个段通常包含一组属于一个逻辑模块的信息,  分段对用户是可见的, 用户编程需要显示地给出段名</li>
<li>页的大小 固定且有系统决定, 段的长度不固定, 决定于用户编写的程序</li>
<li>分页的用户进程空间是一维的, 程序员只要给一个记忆符即可表示一个地址</li>
<li>分段的用户进程空间是二维的, 程序员在标识一个地址时, 既要给出段名, 也要给出段内地址 </li>
<li>分段比分页更容易实现信息的共享和保护.<ul>
<li>不能修改的代码称为纯代码或可重入代码(不属于临界资源), 可以共享. 可修改的代码不能共享.</li>
</ul>
</li>
<li>分页 单级页表 第一次访存–查内存中的页表, 第二次访存–访问目标内存单元. </li>
<li>分段 第一次访存–查内存中的段表 第二次访存–访问目标内存单元 (也可以利用快表)</li>
</ul>
</li>
</ul>
<h4 id="小结-38"><a href="#小结-38" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115000543860.png" alt="image-20230115000543860"></p>
<h3 id="3-1-11-段页式管理方式"><a href="#3-1-11-段页式管理方式" class="headerlink" title="3.1.11 段页式管理方式"></a>3.1.11 段页式管理方式</h3><ul>
<li>分页, 发呢段优缺点分析<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115000702138.png" alt="image-20230115000702138"></li>
</ul>
</li>
<li>段, 页式管理<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115000927840.png" alt="image-20230115000927840"></li>
</ul>
</li>
<li>段表, 页表<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115004120414.png" alt="image-20230115004120414"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115004308094.png" alt="image-20230115004308094"></li>
</ul>
</li>
</ul>
<h4 id="小结-39"><a href="#小结-39" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115005116518.png" alt="image-20230115005116518"></p>
<h3 id="3-2-1-虚拟内存的基本概念-帮助内存扩充"><a href="#3-2-1-虚拟内存的基本概念-帮助内存扩充" class="headerlink" title="3.2.1 虚拟内存的基本概念 (帮助内存扩充)"></a>3.2.1 虚拟内存的基本概念 (帮助内存扩充)</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115005704098.png" alt="image-20230115005704098"></p>
<ul>
<li>传统存储管理方式的特征, 缺点<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115010313687.png" alt="image-20230115010313687"></li>
<li>一次性<ul>
<li>作业必须一次全部装入内存后才能开始运行. 这会造成两个问题<ul>
<li>作业很大时不能全部装入内存, 导致大作业无法运行</li>
<li>当大量作业要求运行时, 由于内存无法容纳所有作业, 因此只有少量作业能运行, 导致多道程序并发度下降</li>
</ul>
</li>
</ul>
</li>
<li>驻留性<ul>
<li>一旦作业被装入内存就会一直驻留在内存中, 直至作业运行结束. 事实上, 一个时间段内, 只需要访问作业的一小部分数据即可正常运行.</li>
</ul>
</li>
</ul>
</li>
<li>局部性原理<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115011200605.png" alt="image-20230115011200605"></li>
<li>高速缓冲技术<ul>
<li>常用在高速的存储器</li>
<li>暂时用不到就放到低俗存储器</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存的定义和特征<ul>
<li>基于局部性原理, 在程序装入时, 可以将程序中很快会用到的部分装入内存, 暂时不用的留在外存, 就可以让程序开始执行</li>
<li>执行过程中, 当访问的信息不在内存时, 由操作系统负责将所需信息从外存调入内存, 然后继续</li>
<li>若内存空间不够, 由操作系统负责将内存中暂时用不到的信息交换出外存</li>
<li>在操作系统管理下, 用户看起来似乎有一个比实际内存大的多的内存</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115021306098.png" alt="image-20230115021306098"></li>
<li>三个主要特征<ul>
<li>多次性<ul>
<li>无需一次全部装入, 分多次调入</li>
</ul>
</li>
<li>对换性<ul>
<li>在作业运行时无需常驻内存, 允许换入换出</li>
</ul>
</li>
<li>虚拟性<ul>
<li>逻辑上扩充了内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存技术的实现<ul>
<li>建立在离散基础之上</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115021622927.png" alt="image-20230115021622927"></li>
</ul>
</li>
</ul>
<h4 id="小结-40"><a href="#小结-40" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115021711742.png" alt="image-20230115021711742"></p>
<p>​	</p>
<h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115021809233.png" alt="image-20230115021809233"></p>
<ul>
<li>页表机制<ul>
<li>与基本分页管理相比, 请求分页管理中, 为了实现 请求网页, 操作系统需要知道每个页面是否已经调入内存; 如果灭调入, 那么也需要知道该页面在外存中存放的位置</li>
<li>系统需要指标决定换出哪个页面. 有些页面没修改过, 就不用浪费时间协会外存, 有些页面修改过, 就需要将外存的旧数据覆盖, 因此, 操作系统也需要记录各个页面是否被修改过的信息.</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115031226185.png" alt="image-20230115031226185"></li>
</ul>
</li>
<li>缺页中断机构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115034513595.png" alt="image-20230115034513595"></li>
<li>缺页中断时因为当前执行的指令想要访问的目标页面为调入内存而产生的, 因此属于内中断</li>
<li>一条指令再执行期间, 可能产生多次缺页中断</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115034617254.png" alt="image-20230115034617254"></li>
</ul>
</li>
<li>地址变化机构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115034725805.png" alt="image-20230115034725805"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115034852210.png" alt="image-20230115034852210"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115035012704.png" alt="image-20230115035012704"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115035024375.png" alt="image-20230115035024375"></li>
</ul>
</li>
</ul>
<h4 id="小结-41"><a href="#小结-41" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115035204835.png" alt="image-20230115035204835"></p>
<h3 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2.3 页面置换算法"></a>3.2.3 页面置换算法</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115035321000.png" alt="image-20230115035321000"></p>
<ul>
<li><p>最佳置换算法 OPT</p>
<ul>
<li>每次选择淘汰的页面将是以后永远不适用或者在最长时间内不被访问的页面, 可以保证最低的缺页率</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115035659747.png" alt="image-20230115035659747"></li>
<li>无法实现 因为不能预判页面访问</li>
</ul>
</li>
<li><p>先进先出置换算法 FIFO (队列)</p>
<ul>
<li>每次淘汰最先进入的</li>
<li>内存块越多, 缺页次数越多</li>
<li>Belady 异常 – 当为进程分配的物理块增大时, 缺页次数不减反增</li>
<li>只有FIFO会产生Belady异常, FIFO虽然实现简单, 但算法性能差</li>
</ul>
</li>
<li><p>最近最久未使用置换算法 LRU least recently used</p>
<ul>
<li>每次淘汰的页面是最近最久未使用的页面</li>
<li>赋予字段 记录该页面自从上次被访问以来所经历的时间t, 淘汰是选择t最大的</li>
<li>性能好, 但是实现困难大, 开销大</li>
</ul>
</li>
<li><p>时钟置换算法 CLOCK &#x2F;最近未用算法 NRU</p>
<ul>
<li>最佳置换算法性能最好, 但无法实现</li>
<li>先进先出置换算法 实现简单, 但性能差</li>
<li>最近最久未使用算法性能最好, 最接近 OPT 但是需要专门硬件支持, 算法开销大</li>
<li>时钟置换算法是一种性能和开销比较均衡的算法 </li>
<li>实现<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115164114286.png" alt="image-20230115164114286"></li>
</ul>
</li>
</ul>
</li>
<li><p>改进型的始终置换算法</p>
<ul>
<li>简单的始终置换算法仅考虑一个页面最近是否被访问过, 事实上, 如果被淘汰的页面没有被修改过, 就不需要执行I&#x2F;O操作写回外存, 只有被淘汰的页面被修改过时, 才需要写回外存.</li>
<li>在其他条件相同时, 应有限淘汰没有修改过的页面, 避免I&#x2F;O操作</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115165552716.png" alt="image-20230115165552716"></li>
</ul>
</li>
</ul>
<h4 id="小结-42"><a href="#小结-42" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115165619514.png" alt="image-20230115165619514"></p>
<h3 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115165654670.png" alt="image-20230115165654670"></p>
<ul>
<li>驻留集<ul>
<li>指请求分页存储管理中给进程分配物理块的集合. 在采用了虚拟存储技术的系统中, 驻留集一般小于进程总大小</li>
<li>若驻留集太小, 会导致缺页频繁, 驻留集太大, 又会导致多道程序并发度下下降</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115170912799.png" alt="image-20230115170912799"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115170921104.png" alt="image-20230115170921104"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115170959000.png" alt="image-20230115170959000"></li>
</ul>
</li>
<li>页面分配 置换策略<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171044559.png" alt="image-20230115171044559"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171157009.png" alt="image-20230115171157009"><ul>
<li>锁定 重要数据会被锁定</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171251301.png" alt="image-20230115171251301"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171306314.png" alt="image-20230115171306314"></li>
</ul>
</li>
<li>调入页面时机<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171331224.png" alt="image-20230115171331224"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171408492.png" alt="image-20230115171408492"></li>
</ul>
</li>
<li>调入页面位置<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171458598.png" alt="系统拥有足够兑换区空间"></li>
<li>系统拥有足够的对换区空间, 页面调入调出是内存与对换区之间进行, 这样可以保证页面调入调出速度很快(进程运行前, 进程相关数据从文件区调入对换区)</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171845677.png" alt="image-20230115171845677"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171829423.png" alt="image-20230115171829423"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171910803.png" alt="image-20230115171910803"></li>
</ul>
</li>
<li>抖动(颠簸)现象<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115171957207.png" alt="image-20230115171957207"></li>
</ul>
</li>
<li>工作集<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115172011759.png" alt="image-20230115172011759"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115172046434.png" alt="image-20230115172046434"></li>
<li>一般来说 驻留集大小不能小于工作集大小, 否则会频繁缺页</li>
</ul>
</li>
</ul>
<h4 id="小结-43"><a href="#小结-43" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115172317995.png" alt="image-20230115172317995"></p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1-1-初识文件管理"><a href="#4-1-1-初识文件管理" class="headerlink" title="4.1.1 初识文件管理"></a>4.1.1 初识文件管理</h3><ul>
<li>文件属性<ul>
<li>文件名</li>
<li>标识符</li>
<li>类型</li>
<li>位置</li>
<li>创建时间, 上次修改, 文件所有者</li>
<li>保护信息</li>
</ul>
</li>
<li>组织<ul>
<li>无结构<ul>
<li>一系列二进制或字符</li>
</ul>
</li>
<li>有结构<ul>
<li>记录 1-N<ul>
<li>数据项 1-N</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>怎样组织<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115174015605.png" alt="image-20230115174015605"></li>
</ul>
</li>
<li>操作系统向上提供功能<ul>
<li>创建文件 create 系统调用</li>
<li>读文件 read 系统调用</li>
<li>写文件 write 系统调用</li>
<li>删除文件 delete 系统调用</li>
<li>打开文件 open 系统调用</li>
<li>关闭文件 close 系统调用</li>
</ul>
</li>
<li>操作系统向下提供功能 文件如何存放在外存</li>
<li>其他<ul>
<li>文件共享</li>
<li>文件保护</li>
</ul>
</li>
</ul>
<h4 id="小结-44"><a href="#小结-44" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115174448717.png" alt="image-20230115174448717"></p>
<h3 id="4-1-2-文件的逻辑结构"><a href="#4-1-2-文件的逻辑结构" class="headerlink" title="4.1.2 文件的逻辑结构"></a>4.1.2 文件的逻辑结构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115174508275.png" alt="image-20230115174508275"></p>
<ul>
<li>无结构文件 流式文件<ul>
<li>不重要 文件内部是一系列二进制流或字符流,</li>
</ul>
</li>
<li>有结构文件 记录式文件<ul>
<li>存在关键字决定唯一记录</li>
<li>定长记录</li>
<li>可变长记录</li>
<li>顺序文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115175720737.png" alt="image-20230115175720737"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115175740695.png" alt="image-20230115175740695"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115175824522.png" alt="image-20230115175824522"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115180131912.png" alt="image-20230115180131912"></li>
</ul>
</li>
<li>索引文件<ul>
<li>解决查找速度慢</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115180313183.png" alt="image-20230115180313183"></li>
</ul>
</li>
<li>索引顺序文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115184111298.png" alt="image-20230115184111298"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115184203548.png" alt="image-20230115184203548"></li>
<li>多级索引顺序文件</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115184318781.png" alt="image-20230115184318781"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-45"><a href="#小结-45" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115184434089.png" alt="image-20230115184434089"></p>
<h3 id="4-1-3-文件目录"><a href="#4-1-3-文件目录" class="headerlink" title="4.1.3 文件目录"></a>4.1.3 文件目录</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192110207.png" alt="image-20230115192110207"></p>
<ul>
<li>文件控制块 FCB File Control Block<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192216026.png" alt="image-20230115192216026"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192302769.png" alt="对目录进行的操作"></li>
</ul>
</li>
<li>目录结构<ul>
<li>单级目录结构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192405118.png" alt="image-20230115192405118"></li>
</ul>
</li>
<li>两级目录结构<ul>
<li>主文件目录 MFD Master File Directory</li>
<li>文件目录 UFD User File Directory</li>
</ul>
</li>
<li>多级目录结构 树形目录结构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192552744.png" alt="image-20230115192552744"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192604793.png" alt="image-20230115192604793"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192633154.png" alt="image-20230115192633154"></li>
</ul>
</li>
<li>无环图目录结构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115192723015.png" alt="image-20230115192723015"></li>
</ul>
</li>
</ul>
</li>
<li>索引节点 FCB 的改进<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115195019522.png" alt="image-20230115195019522"></li>
</ul>
</li>
</ul>
<h4 id="小结-46"><a href="#小结-46" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115195620881.png" alt="image-20230115195620881"></p>
<h3 id="4-1-4-文件的物理结构-上"><a href="#4-1-4-文件的物理结构-上" class="headerlink" title="4.1.4 文件的物理结构 (上)"></a>4.1.4 文件的物理结构 (上)</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115195833495.png" alt="image-20230115195833495"></p>
<ul>
<li>文件块 磁盘块</li>
<li>文件分配 – 连续分配<ul>
<li>每个文件在磁盘上占有一组连续的块</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115212413329.png" alt="image-20230115212413329"></li>
<li>要求每个文件在磁盘上占有一组连续的块</li>
<li>结论 连续分配的文件在顺序读取时最快</li>
<li>物理上 采用连续分配不方便拓展</li>
<li>存储利用率低, 会产生难以利用的磁盘碎片</li>
</ul>
</li>
<li>文件分配 – 链接分配<ul>
<li>链接分配采用离散分配的方式, 可以为文件分配离散的磁盘块. 分为隐式链接和显式链接</li>
<li>隐式链接<ul>
<li>记录起始结束块号</li>
<li>只支持顺序访问, 不支持随机访问, 查找效率低</li>
<li>方便文件拓展利用率高</li>
</ul>
</li>
<li>显式链接<ul>
<li>把用于链接文件各物理块指针显式的存放在一张表中, 即 文件分配表 FAT File Allocation Table</li>
<li>一个磁盘仅设置一张FAT, 开机时,将其读入内存病常驻内存</li>
<li>逻辑块号转换为物理块号, 不需要读磁盘操作</li>
<li>支持顺序访问, 也支持随机访问(可以直接访问第i块).</li>
<li>文件分配表需要占用一定存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="链接分配小结"><a href="#链接分配小结" class="headerlink" title="链接分配小结"></a>链接分配小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115213454644.png" alt="image-20230115213454644"></p>
<h3 id="4-1-4-文件的物理结构-下"><a href="#4-1-4-文件的物理结构-下" class="headerlink" title="4.1.4 文件的物理结构 (下)"></a>4.1.4 文件的物理结构 (下)</h3><ul>
<li>索引分配<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115213556822.png" alt="image-20230115213556822"></li>
<li>支持随机访问 但索引表占用空间</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230115215439943.png" alt="image-20230115215439943"><ul>
<li>效率低</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030102379.png" alt="image-20230116030102379"><ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030148648.png" alt="image-20230116030148648"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030236169.png" alt="image-20230116030236169"></li>
<li>k层 - k + 1 次读取</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030324581.png" alt="image-20230116030324581"><ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030405151.png" alt="image-20230116030405151"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030432236.png" alt="image-20230116030432236"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="索引分配总结"><a href="#索引分配总结" class="headerlink" title="索引分配总结"></a>索引分配总结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030554967.png" alt="image-20230116030554967"></p>
<h4 id="小结-47"><a href="#小结-47" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116030605017.png" alt="image-20230116030605017"></p>
<h3 id="4-1-5-文件存储空间管理"><a href="#4-1-5-文件存储空间管理" class="headerlink" title="4.1.5 文件存储空间管理"></a>4.1.5 文件存储空间管理</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116031445674.png" alt="image-20230116031445674"></p>
<blockquote>
<p>注意: </p>
<ol>
<li>用什么方式记录组织空闲块?</li>
<li>如何分配磁盘块</li>
<li>如何回收磁盘块</li>
</ol>
</blockquote>
<ul>
<li>存储空间的划分与初始化<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116031646307.png" alt="image-20230116031646307"></li>
</ul>
</li>
<li>存储空间管理<ul>
<li>空闲表法 - 连续分配方式<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116032028270.png" alt="image-20230116032028270"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116032102588.png" alt="image-20230116032102588"></li>
</ul>
</li>
<li>空闲链表法<ul>
<li>空闲盘块链 以盘块为单位</li>
<li>空闲盘区链 以盘区为单位</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116035222678.png" alt="image-20230116035222678"></li>
</ul>
</li>
<li>空闲盘区法<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116035251443.png" alt="image-20230116035251443"></li>
</ul>
</li>
</ul>
</li>
<li>位示图法<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116035558189.png" alt="image-20230116035558189"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116035648137.png" alt="image-20230116035648137"></li>
</ul>
</li>
<li>成组链接法<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116040325301.png" alt="image-20230116040325301"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116040334442.png" alt="image-20230116040334442"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116040502220.png" alt="image-20230116040502220"></li>
<li>一个空闲块<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116040538547.png" alt="image-20230116040538547"></li>
</ul>
</li>
<li>100个空闲块<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116040904444.png" alt="image-20230116040904444"></li>
</ul>
</li>
<li>如何回收<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116041021215.png" alt="image-20230116041021215"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-48"><a href="#小结-48" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116041117756.png" alt="image-20230116041117756"></p>
<h3 id="4-1-6-文件的基本操作"><a href="#4-1-6-文件的基本操作" class="headerlink" title="4.1.6 文件的基本操作"></a>4.1.6 文件的基本操作</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151411185.png" alt="image-20230116151411185"></p>
<ul>
<li>创建文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151520218.png" alt="image-20230116151520218"></li>
</ul>
</li>
<li>删除文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151558704.png" alt="image-20230116151558704"></li>
</ul>
</li>
<li>打开文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151639796.png" alt="image-20230116151639796"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151734205.png" alt="image-20230116151734205"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151756687.png" alt="image-20230116151756687"></li>
</ul>
</li>
<li>关闭文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151834285.png" alt="image-20230116151834285"></li>
</ul>
</li>
<li>读文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116151944607.png" alt="image-20230116151944607"></li>
</ul>
</li>
<li>写文件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116152015092.png" alt="image-20230116152015092"></li>
</ul>
</li>
</ul>
<h4 id="小结-49"><a href="#小结-49" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116152118169.png" alt="image-20230116152118169"></p>
<h3 id="4-1-7-文件共享"><a href="#4-1-7-文件共享" class="headerlink" title="4.1.7 文件共享"></a>4.1.7 文件共享</h3><ul>
<li>基于索引结点的共享方式(硬链接)<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116152309121.png" alt="image-20230116152309121"></li>
</ul>
</li>
<li>基于符号链的共享方式(软链接)<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116152351805.png" alt="image-20230116152351805"></li>
</ul>
</li>
</ul>
<h4 id="小结-50"><a href="#小结-50" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116152513353.png" alt="image-20230116152513353"></p>
<h3 id="4-1-8-文件保护"><a href="#4-1-8-文件保护" class="headerlink" title="4.1.8 文件保护"></a>4.1.8 文件保护</h3><ul>
<li>口令保护<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116154704182.png" alt="image-20230116154704182"></li>
</ul>
</li>
<li>加密保护<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116154801730.png" alt="image-20230116154801730"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116154817417.png" alt="image-20230116154817417"></li>
</ul>
</li>
<li>访问控制<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116154855800.png" alt="image-20230116154855800"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116154918404.png" alt="image-20230116154918404"></li>
</ul>
</li>
</ul>
<h4 id="小结-51"><a href="#小结-51" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116155055303.png" alt="image-20230116155055303"></p>
<h3 id="4-1-9-文件系统的层次结构"><a href="#4-1-9-文件系统的层次结构" class="headerlink" title="4.1.9 文件系统的层次结构"></a>4.1.9 文件系统的层次结构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116155957925.png" alt="image-20230116155957925"></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161604056.png" alt="image-20230116161604056"></p>
<h3 id="4-2-1-磁盘的结构"><a href="#4-2-1-磁盘的结构" class="headerlink" title="4.2.1 磁盘的结构"></a>4.2.1 磁盘的结构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161623233.png" alt="image-20230116161623233"></p>
<ul>
<li>磁盘, 磁道, 扇区<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161723668.png" alt="image-20230116161723668"></li>
</ul>
</li>
<li>读&#x2F;写数据<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161755093.png" alt="image-20230116161755093"></li>
</ul>
</li>
<li>盘面, 柱面<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161829160.png" alt="image-20230116161829160"></li>
</ul>
</li>
<li>磁盘的物理地址<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161929317.png" alt="image-20230116161929317"></li>
</ul>
</li>
<li>磁盘的分类<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161945685.png" alt="image-20230116161945685"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116161954468.png" alt="image-20230116161954468"></li>
</ul>
</li>
</ul>
<h4 id="小结-52"><a href="#小结-52" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116162009373.png" alt="image-20230116162009373"></p>
<h3 id="4-2-2-磁盘调度算法"><a href="#4-2-2-磁盘调度算法" class="headerlink" title="4.2.2 磁盘调度算法"></a>4.2.2 磁盘调度算法</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116162029726.png" alt="image-20230116162029726"></p>
<ul>
<li>一次磁盘读写操作时间<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116162242669.png" alt="image-20230116162242669"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116162249957.png" alt="image-20230116162249957"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116162331527.png" alt="image-20230116162331527"></li>
<li>操作系统只能优化寻道时间, 其他只与磁盘转速相关</li>
</ul>
</li>
<li>先来先服务 FCFS<ul>
<li>按照请求访问的先后顺序进行调度</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116162945022.png" alt="image-20230116162945022"></li>
</ul>
</li>
<li>最短寻找时间优先 SSTF<ul>
<li>优先处理磁道与当前磁头最近的磁道</li>
<li>只选择眼前最优, 但总体未必</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116163104692.png" alt="image-20230116163104692"></li>
</ul>
</li>
<li>扫描算法 SCAN<ul>
<li>磁头移动到最外侧才能往内移动, 移动到最内才能往外移动, 也叫电梯算法</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116163322025.png" alt="image-20230116163322025"></li>
</ul>
</li>
<li>LOOK 调度算法<ul>
<li>如果在移动方向上没有了请求, 则改变方向</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116163515098.png" alt="image-20230116163515098"></li>
</ul>
</li>
<li>循环扫描算法 C-SCAN<ul>
<li>SCAN各位置磁道相应频率不平均, C-SCAN就是为了解决这个问题. 规定只有刺头朝某个特定方向移动时, 草冲击力磁道访问请求, 而返回时, 直接快速移动至起始端, 而不处理任何请求</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116202740326.png" alt="image-20230116202740326"></li>
</ul>
</li>
<li>C-Look 调度算法<ul>
<li>改善C-SCAN只有到达最边上才改变方向, C-Look在发现移动方向上没有请求直接返回</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116202858150.png" alt="image-20230116202858150"></li>
</ul>
</li>
</ul>
<h4 id="小结-53"><a href="#小结-53" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116202957645.png" alt="image-20230116202957645"></p>
<h3 id="4-2-3-减少磁盘延迟时间的方法"><a href="#4-2-3-减少磁盘延迟时间的方法" class="headerlink" title="4.2.3 减少磁盘延迟时间的方法"></a>4.2.3 减少磁盘延迟时间的方法</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203050493.png" alt="image-20230116203050493"></p>
<ul>
<li>交替编号<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203113436.png" alt="image-20230116203113436"></li>
</ul>
</li>
<li>磁盘地址结构的设计<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203250574.png" alt="image-20230116203250574"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203349398.png" alt="image-20230116203349398"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203329784.png" alt="image-20230116203329784"></li>
</ul>
</li>
<li>错位命名<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203604505.png" alt="image-20230116203604505"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203550585.png" alt="image-20230116203550585"></li>
</ul>
</li>
</ul>
<h4 id="小结-54"><a href="#小结-54" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116203739162.png" alt="image-20230116203739162"></p>
<h3 id="4-2-5-磁盘的管理"><a href="#4-2-5-磁盘的管理" class="headerlink" title="4.2.5 磁盘的管理"></a>4.2.5 磁盘的管理</h3><ul>
<li>磁盘初始化<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204022261.png" alt="image-20230116204022261"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204031595.png" alt="image-20230116204031595"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204044445.png" alt="image-20230116204044445"></li>
</ul>
</li>
<li>引导块<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204103681.png" alt="image-20230116204103681"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204123277.png" alt="image-20230116204123277"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204155014.png" alt="image-20230116204155014"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204202711.png" alt="image-20230116204202711"></li>
</ul>
</li>
<li>坏块的管理<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204247270.png" alt="image-20230116204247270"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204315032.png" alt="image-20230116204315032"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204332718.png" alt="image-20230116204332718"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204339799.png" alt="image-20230116204339799"></li>
</ul>
</li>
</ul>
<h4 id="小结-55"><a href="#小结-55" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230116204355668.png" alt="image-20230116204355668"></p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1-1-I-O设备的概念和分类"><a href="#5-1-1-I-O设备的概念和分类" class="headerlink" title="5.1.1 I-O设备的概念和分类"></a>5.1.1 I-O设备的概念和分类</h3><ul>
<li>IO设备<ul>
<li>输入输出设备</li>
</ul>
</li>
<li>分类<ul>
<li>人机交互</li>
<li>存储设备</li>
<li>网络通信设备</li>
</ul>
</li>
<li>速度分类<ul>
<li>低速</li>
<li>中速</li>
<li>高速</li>
</ul>
</li>
<li>信息交换单位<ul>
<li>块设备</li>
<li>字符设备</li>
</ul>
</li>
</ul>
<h4 id="小结-56"><a href="#小结-56" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117193901490.png" alt="image-20230117193901490"></p>
<h3 id="5-1-2-I-O控制器"><a href="#5-1-2-I-O控制器" class="headerlink" title="5.1.2 I-O控制器"></a>5.1.2 I-O控制器</h3><ul>
<li>机械部件<ul>
<li>执行具体IO</li>
</ul>
</li>
<li>电子部件<ul>
<li>中介</li>
<li>IO控制器</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117194038547.png" alt="image-20230117194038547"></li>
<li>组成<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117194219826.png" alt="image-20230117194219826"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117194245740.png" alt="image-20230117194245740"></li>
</ul>
</li>
<li>内存映像IO 急促拿起独立编制<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117194329354.png" alt="image-20230117194329354"></li>
</ul>
</li>
</ul>
<h4 id="小结-57"><a href="#小结-57" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117194344796.png" alt="image-20230117194344796"></p>
<h3 id="5-1-3-I-O控制方式"><a href="#5-1-3-I-O控制方式" class="headerlink" title="5.1.3 I-O控制方式"></a>5.1.3 I-O控制方式</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230117194433445.png" alt="image-20230117194433445"></p>
<ul>
<li><p>程序直接控制方式</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230119034345195.png" alt="image-20230119034345195"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230121172302195.png" alt="image-20230121172302195"></li>
</ul>
</li>
<li><p>中断驱动方式</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173211051.png" alt="image-20230123173211051"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173316715.png" alt="image-20230123173316715"></li>
</ul>
</li>
<li><p>DMA方式</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173507980.png" alt="image-20230123173507980"></li>
<li>DMA控制器<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173633051.png" alt="image-20230123173633051"></li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173801831.png" alt="image-20230123173801831"></li>
</ul>
</li>
<li><p>通道控制方式</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173903690.png" alt="image-20230123173903690"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123173955300.png" alt="image-20230123173955300"></li>
</ul>
</li>
</ul>
<h4 id="小结-58"><a href="#小结-58" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123181418468.png" alt="image-20230123181418468"></p>
<h3 id="5-1-4-I-O软件层次结构"><a href="#5-1-4-I-O软件层次结构" class="headerlink" title="5.1.4 I-O软件层次结构"></a>5.1.4 I-O软件层次结构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123190912251.png" alt="image-20230123190912251"></p>
<ul>
<li>用户层软件<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123191830066.png" alt="image-20230123191830066"></li>
</ul>
</li>
<li>设备独立性软件<ul>
<li>又被称为设备无关性软件, 与设备的硬件特性无关的功能几乎都在这一层实现. </li>
<li>主要实现的功能<ul>
<li>向上层提供统一的调用接口(如 读写系统调用)</li>
<li>设备的保护<ul>
<li>设备被看为一种特殊的文件</li>
</ul>
</li>
<li>差错处理</li>
<li>设备的分配与回收</li>
<li>数据缓冲区管理<ul>
<li>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li>
</ul>
</li>
<li>建立逻辑设备名到物理设备名的映射关系, 根据设备类型选择调用相应的驱动程序<ul>
<li>设备独立性软件通过逻辑设备表 LUT Logical Unit Table 来确定物理设备, 并找到该设备对应的设备驱动程序</li>
<li>两种方式管理LUT<ul>
<li>只有一张LUT 只适合单用户</li>
<li>每个用户设置一张LUT 存放在用户管理进程的PCB中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设备驱动程序<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123195817160.png" alt="image-20230123195817160"></li>
<li>驱动程序会以一个独立进程方式存在</li>
</ul>
</li>
<li>中断处理程序<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200010881.png" alt="image-20230123200010881"></li>
</ul>
</li>
</ul>
<h4 id="小结-59"><a href="#小结-59" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200040119.png" alt="image-20230123200040119"></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200055978.png" alt="image-20230123200055978"></p>
<p>​	</p>
<h3 id="5-1-5-I-O核心子系统"><a href="#5-1-5-I-O核心子系统" class="headerlink" title="5.1.5 I-O核心子系统"></a>5.1.5 I-O核心子系统</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200120375.png" alt="image-20230123200120375"></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200204085.png" alt="image-20230123200204085"></p>
<ul>
<li>IO调度<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200235521.png" alt="image-20230123200235521"></li>
</ul>
</li>
<li>设备保护<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200309305.png" alt="image-20230123200309305"></li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200332917.png" alt="image-20230123200332917"></p>
<h3 id="5-1-6-假脱机技术"><a href="#5-1-6-假脱机技术" class="headerlink" title="5.1.6 假脱机技术"></a>5.1.6 假脱机技术</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200345160.png" alt="image-20230123200345160"></p>
<ul>
<li>脱机技术<ul>
<li>脱离主机的控制进行输入输出操作</li>
<li>缓解CPU与慢速IO,速度矛盾</li>
<li>即使CPU忙碌, 也可以提前输入输出数据</li>
</ul>
</li>
<li>假脱机技术<ul>
<li>SPOOLing 技术<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200639986.png" alt="image-20230123200639986"></li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200819507.png" alt="image-20230123200819507"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200846065.png" alt="image-20230123200846065"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200854468.png" alt="image-20230123200854468"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123200923448.png" alt="image-20230123200923448"></li>
</ul>
</li>
<li>共享打印机原理分析<ul>
<li>独立设备<ul>
<li>只允许各个进程串行使用的设备 一段时间只能满足一个进程的请求</li>
</ul>
</li>
<li>共享设备<ul>
<li>允许多个进程“同时”使用的设备, 可同时满足多个进程的使用需求(微观上交替使用)</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123201720519.png" alt="image-20230123201720519"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123201823975.png" alt="image-20230123201823975"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123201851205.png" alt="image-20230123201851205"></li>
</ul>
</li>
</ul>
<h4 id="小结-60"><a href="#小结-60" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123201923913.png" alt="image-20230123201923913"></p>
<h3 id="5-1-7-设备的分配与回收"><a href="#5-1-7-设备的分配与回收" class="headerlink" title="5.1.7 设备的分配与回收"></a>5.1.7 设备的分配与回收</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123201944340.png" alt="image-20230123201944340"></p>
<ul>
<li>设备分配时考虑因素<ul>
<li>设备固有属性<ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123202050078.png" alt="image-20230123202050078"></li>
</ul>
</li>
<li>设备分配的算法<ul>
<li>先来先服务</li>
<li>…</li>
</ul>
</li>
<li>设备分配中的安全性<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123202608371.png" alt="image-20230123202608371"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123202646077.png" alt="image-20230123202646077"></li>
</ul>
</li>
</ul>
</li>
<li>静态分配和动态分配<ul>
<li>静态分配<ul>
<li>进程运行前为其分配全部资源, 结束后归还资源</li>
</ul>
</li>
<li>动态分配<ul>
<li>进程运行中动态申请设备资源</li>
</ul>
</li>
</ul>
</li>
<li>设备分配管理中的数据结构<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123202828689.png" alt="image-20230123202828689"></li>
<li>设备控制表 DCT<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123202916373.png" alt="image-20230123202916373"></li>
</ul>
</li>
<li>控制器控制表 COCT<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123202952274.png" alt="image-20230123202952274"></li>
</ul>
</li>
<li>通道控制表 CHCT<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123203039858.png" alt="image-20230123203039858"></li>
</ul>
</li>
<li>系统设别表 SDT 记录了系统中全部设备的情况<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123203233115.png" alt="image-20230123203233115"></li>
</ul>
</li>
<li>设备分配步骤<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123203252170.png" alt="image-20230123203252170"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230123203301313.png" alt="image-20230123203301313"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084110990.png" alt="image-20230124084110990"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084125947.png" alt="image-20230124084125947"></li>
<li>只有设备, 控制器, 通道三者都分配成功时, 这次设备分派才算成功, 之后便可启动IO设备进行数据传送</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084224526.png" alt="image-20230124084224526"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084322999.png" alt="image-20230124084322999"></li>
</ul>
</li>
<li>设备分配步骤都改进<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084355906.png" alt="image-20230124084355906"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084420420.png" alt="image-20230124084420420"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结-61"><a href="#小结-61" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084447073.png" alt="image-20230124084447073"></p>
<h3 id="5-1-8-缓冲区管理"><a href="#5-1-8-缓冲区管理" class="headerlink" title="5.1.8 缓冲区管理"></a>5.1.8 缓冲区管理</h3><ul>
<li><p>什么是缓冲区, 有什么用</p>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084544242.png" alt="image-20230124084544242"></p>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084912459.png" alt="image-20230124084912459"></p>
</li>
<li><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124084937787.png" alt="image-20230124084937787"></p>
</li>
<li><p>单缓冲</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124085008414.png" alt="image-20230124085008414"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124085117679.png" alt="image-20230124085117679"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124085407980.png" alt="image-20230124085407980"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124085346491.png" alt="image-20230124085346491"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124085517333.png" alt="image-20230124085517333"></li>
</ul>
</li>
<li><p>双缓冲</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124085545456.png" alt="image-20230124085545456"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124090526998.png" alt="image-20230124090526998"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124090742409.png" alt="image-20230124090742409"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124090824452.png" alt="image-20230124090824452"></li>
</ul>
</li>
<li><p>单双缓冲再通信时的区别</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124090905041.png" alt="image-20230124090905041"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124090924657.png" alt="image-20230124090924657"></li>
</ul>
</li>
<li><p>循环缓冲区</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124091016143.png" alt="image-20230124091016143"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124091034169.png" alt="image-20230124091034169"></li>
</ul>
</li>
<li><p>缓冲池</p>
<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124091051304.png" alt="image-20230124091051304"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124091105827.png" alt="image-20230124091105827"></li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124091154799.png" alt="image-20230124091154799"></li>
</ul>
</li>
</ul>
<h4 id="小结-62"><a href="#小结-62" class="headerlink" title="小结"></a>小结</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230124091219637.png" alt="image-20230124091219637"></p>
<hr>
<p>OVER</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="supercoko.github.io">SuperCoko</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://supercoko.github.io/2023/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://supercoko.github.io/2023/01/04/操作系统/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://supercoko.github.io" target="_blank">Coko</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://images4.alphacoders.com/129/1297318.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/16/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><img class="prev-cover" src="https://cdn.anime-pictures.net/previews/009/0097e7d2ea607825f51cc2472a7f3d5a_cp.png.avif" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">测试开发学习路线</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/02/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><img class="next-cover" src="https://cdn.anime-pictures.net/previews/ce2/ce25aebef3bbccbd6479bc617328e04c_bp.jpg.avif" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode刷题-剑指offer</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-text">1.1 操作系统概念, 功能和目标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-text">功能和目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-text">1.2 操作系统的四个特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">1.3 操作系统的发展和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1.4 操作系统的运行机制和体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">1.5 中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1.6 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-text">第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%84%E6%88%90%E5%92%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%89%B9%E5%BE%81"><span class="toc-text">2.1.1 进程的定义组成和组织方式特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1.2 进程的状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2.1.3 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.1.4 进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.5 线程概念和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%B1%82%E6%AC%A1"><span class="toc-text">2.2.1 处理机调度的概念,层次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-10"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA-%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B-%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2 进程调度的时机,切换与过程,方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-%E4%B8%8D%E6%98%AF%E9%87%8D%E7%82%B9-x2F-%E9%9C%80%E8%A6%81%E7%90%86%E8%A7%A3"><span class="toc-text">小结(不是重点&#x2F;需要理解)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.2.3 调度算法的评价指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-11"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-FCFS-SJF-HRRN%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.4 FCFS, SJF, HRRN调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-12"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-%E4%BC%98%E5%85%88%E7%BA%A7-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">2.2.5 调度算法:时间片轮转, 优先级, 多级反馈队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-13"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">2.3.1 进程同步, 进程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-14"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.2 进程互斥的软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-15"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3 进程互斥的硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-16"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.4 信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-17"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-%E5%90%8C%E6%AD%A5-%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-text">2.3.5 用信号量实现进程互斥, 同步, 前驱关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-18"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.6 生产者-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-19"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-7-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E4%B9%8B%E9%97%AE%E9%A2%98-%E5%A4%9A%E7%B1%BB"><span class="toc-text">2.3.7 多生产者-多消费之问题 (多类)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-20"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-8-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98-1%E5%AF%B9%E5%A4%9A"><span class="toc-text">2.3.8 吸烟者问题(1对多)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-21"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-9-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98-%E8%AF%BB%E6%96%87%E4%BB%B6%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%AF%B9%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D-%E5%9B%A0%E6%AD%A4%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C"><span class="toc-text">2.3.9 读者-写者问题 (读文件是不会对文件产生影响, 因此可以并行)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-22"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-10-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98-%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B8%AA%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E6%97%B6"><span class="toc-text">2.3.10 哲学家进餐问题(一个进程需要多个临界资源时)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-23"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-11-%E7%AE%A1%E7%A8%8B"><span class="toc-text">2.3.11 管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-24"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.4.1 死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-25"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.2 死锁的处理策略 - 预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-26"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.3 死锁的处理策略 - 避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-27"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5-%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-text">2.4.4 死锁的处理策略 - 检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-28"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">3.1.1 内存的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-29"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.2 内存管理的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-30"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.1.3 覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-31"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.4 连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-32"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5 动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-33"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.6 基本分页存储管理的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-34"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-7-%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3.1.7 基本地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-35"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-8-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3.1.8 具有快表的地址交换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-36"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-9-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">3.1.9 两级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-37"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-10-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.10 基本分段存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-38"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-11-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.11 段页式管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-39"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E5%B8%AE%E5%8A%A9%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85"><span class="toc-text">3.2.1 虚拟内存的基本概念 (帮助内存扩充)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-40"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2.2 请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-41"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">3.2.3 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-42"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">3.2.4 页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-43"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-text">第四章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">4.1.1 初识文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-44"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">4.1.2 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-45"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">4.1.3 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-46"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-%E4%B8%8A"><span class="toc-text">4.1.4 文件的物理结构 (上)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D%E5%B0%8F%E7%BB%93"><span class="toc-text">链接分配小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-%E4%B8%8B"><span class="toc-text">4.1.4 文件的物理结构 (下)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%E6%80%BB%E7%BB%93"><span class="toc-text">索引分配总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-47"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">4.1.5 文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-48"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">4.1.6 文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-49"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">4.1.7 文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-50"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-text">4.1.8 文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-51"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">4.1.9 文件系统的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">4.2.1 磁盘的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-52"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">4.2.2 磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-53"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.3 减少磁盘延迟时间的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-54"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">4.2.5 磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-55"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">5.1.1 I-O设备的概念和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-56"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">5.1.2 I-O控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-57"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">5.1.3 I-O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-58"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">5.1.4 I-O软件层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-59"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-I-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">5.1.5 I-O核心子系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-text">5.1.6 假脱机技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-60"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-7-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-text">5.1.7 设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-61"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-8-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">5.1.8 缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-62"><span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By SuperCoko</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/izumi.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>